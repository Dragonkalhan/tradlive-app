```html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradLive - Mode T√©l√©phone</title>
    <style>
        /* Styles CSS optimis√©s pour mobile */
        body {
            font-family: Arial, sans-serif;
            max-width: 100%;
            margin: 0 auto;
            padding: 15px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
        }
        .device-indicator {
            text-align: center;
            background-color: #3498db;
            color: white;
            padding: 8px;
            border-radius: 20px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        select, button {
            padding: 10px 15px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            font-size: 16px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #2980b9;
        }
        #mic-button {
            padding: 15px;
            font-size: 18px;
            border-radius: 50px;
            background-color: #3498db;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            margin: 20px 0;
            display: block;
            width: 100%;
            height: 60px;
        }
        #mic-button.active {
            background-color: #27ae60;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(39, 174, 96, 0); }
            100% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0); }
        }
        #status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
            color: #666;
        }
        .text-container {
            margin-top: 20px;
        }
        .text-box {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin-bottom: 15px;
        }
        .text-box h3 {
            font-size: 16px;
            margin-top: 0;
            color: #333;
        }
        #original-text, #translated-text {
            min-height: 60px;
            font-size: 16px;
            line-height: 1.5;
        }
        .language-label {
            font-weight: bold;
            color: #333;
        }
        .tunnel-info {
            font-size: 12px;
            margin-top: 5px;
            color: #666;
            text-align: center;
        }
        .instructions {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        /* Styles pour les nouvelles fonctionnalit√©s */
        .wave-container {
            display: none;
            justify-content: center;
            align-items: center;
            height: 40px;
            margin: 10px 0;
        }
        .wave-container.active {
            display: flex;
        }
        .wave-bar {
            display: inline-block;
            width: 5px;
            background-color: #3498db;
            margin: 0 3px;
            border-radius: 2px;
            animation: waveAnimation 0.5s infinite alternate;
        }
        @keyframes waveAnimation {
            0% { height: 10px; }
            100% { height: 30px; }
        }
        .wave-bar:nth-child(1) { animation-delay: 0.1s; }
        .wave-bar:nth-child(2) { animation-delay: 0.2s; }
        .wave-bar:nth-child(3) { animation-delay: 0.3s; }
        .wave-bar:nth-child(4) { animation-delay: 0.4s; }
        .wave-bar:nth-child(5) { animation-delay: 0.3s; }
        
        /* Statut de connexion */
        .connection-status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            margin-left: 5px;
        }
        .connection-status.connected {
            background-color: #2ecc71;
        }
        .connection-status.disconnected {
            background-color: #e74c3c;
        }
        
        /* Micro level indicator */
        .mic-level-indicator {
            width: 100%;
            height: 5px;
            background-color: #eee;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        .mic-level-indicator.active {
            display: block;
        }
        .mic-level-bar {
            height: 100%;
            width: 0%;
            background-color: #3498db;
            transition: width 0.1s ease-out;
        }
        
        /* Debug info */
        .debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            max-width: 250px;
            display: none;
        }
        .debug-info.visible {
            display: block;
        }
    </style>
</head>
<body>
    <h1>TradLive - Traduction en temps r√©el</h1>
    <div class="device-indicator">Mode T√©l√©phone</div>
    
    <div class="instructions">
        <strong>Comment utiliser :</strong> S√©lectionnez la langue de votre interlocuteur, puis parlez en fran√ßais. Votre interlocuteur verra la traduction s'afficher sur son √©cran d'ordinateur.
    </div>
    
    <div id="status">S√©lectionnez une langue et cliquez sur le micro pour parler en fran√ßais</div>
    <select id="lang-select" name="lang">
        <option value="en" {% if lang == "en" %}selected{% endif %}>Anglais</option>
        <option value="es" {% if lang == "es" %}selected{% endif %}>Espagnol</option>
        <option value="de" {% if lang == "de" %}selected{% endif %}>Allemand</option>
        <option value="it" {% if lang == "it" %}selected{% endif %}>Italien</option>
        <option value="pt" {% if lang == "pt" %}selected{% endif %}>Portugais</option>
        <option value="ru" {% if lang == "ru" %}selected{% endif %}>Russe</option>
        <option value="zh-CN" {% if lang == "zh-CN" %}selected{% endif %}>Chinois</option>
        <option value="ja" {% if lang == "ja" %}selected{% endif %}>Japonais</option>
        <option value="ar" {% if lang == "ar" %}selected{% endif %}>Arabe</option>
        <option value="uk" {% if lang == "uk" %}selected{% endif %}>Ukrainien</option>
        <option value="fa" {% if lang == "fa" %}selected{% endif %}>Persan</option>
        <option value="hi" {% if lang == "hi" %}selected{% endif %}>Hindi</option>
        <option value="bn" {% if lang == "bn" %}selected{% endif %}>Bengali</option>
        <option value="te" {% if lang == "te" %}selected{% endif %}>T√©lougou</option>
        <option value="mr" {% if lang == "mr" %}selected{% endif %}>Marathi</option>
    </select>
    
    <!-- Animation visuelle pour le micro -->
    <div class="wave-container" id="wave-animation">
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
    </div>
    
    <button id="mic-button">üé§ Parler en Fran√ßais</button>
    
    <!-- Indicateur de niveau audio -->
    <div class="mic-level-indicator" id="mic-level">
        <div class="mic-level-bar" id="mic-level-bar"></div>
    </div>
    
    <div class="text-container">
        <div class="text-box">
            <h3>Texte Original (Fran√ßais)</h3>
            <p id="original-text">{{ original }}</p>
        </div>
        <div class="text-box">
            <h3>Traduction (<span class="language-label" id="target-lang-label">{{ lang }}</span>)</h3>
            <p id="translated-text">{{ translated }}</p>
        </div>
    </div>
    
    <div id="server-mode" class="tunnel-info">
        Connexion: <span id="connection-status" class="connection-status disconnected">D√©connect√©</span>
    </div>
    
    <!-- Debug info -->
    <div class="debug-info" id="debug-info">
        <h4>Diagnostic</h4>
        <div id="debug-content">Chargement...</div>
    </div>
    
    <script>
        // Code JavaScript sp√©cifique au t√©l√©phone - Mode "Parler" uniquement
        document.addEventListener('DOMContentLoaded', function() {
            const micButton = document.getElementById('mic-button');
            const status = document.getElementById('status');
            const originalText = document.getElementById('original-text');
            const translatedText = document.getElementById('translated-text');
            const langSelect = document.getElementById('lang-select');
            const serverModeInfo = document.getElementById('server-mode');
            const targetLangLabel = document.getElementById('target-lang-label');
            const connectionStatus = document.getElementById('connection-status');
            const waveAnimation = document.getElementById('wave-animation');
            const micLevelIndicator = document.getElementById('mic-level');
            const micLevelBar = document.getElementById('mic-level-bar');
            const debugInfo = document.getElementById('debug-info');
            const debugContent = document.getElementById('debug-content');

            let recognition;
            let isListening = false;
            let finalTranscript = '';
            let processingTimeout = null;
            let heartbeatInterval = null;
            let audioContext = null;
            let analyser = null;
            let microphone = null;
            let lastConnectionCheck = Date.now();
            let isConnected = false;
            let consecutiveErrors = 0;
            
            // Activer/d√©sactiver le debug avec un triple clic sur le statut
            let clickCount = 0;
            status.addEventListener('click', function() {
                clickCount++;
                if (clickCount === 3) {
                    debugInfo.classList.toggle('visible');
                    updateDebugInfo();
                    clickCount = 0;
                }
                
                // R√©initialiser le compteur apr√®s un d√©lai
                setTimeout(() => { clickCount = 0; }, 500);
            });
            
            // Fonction pour mettre √† jour les infos de d√©bogage
            function updateDebugInfo() {
                if (!debugInfo.classList.contains('visible')) return;
                
                // Collecter les infos sur le navigateur et l'audio
                const browserInfo = `Navigateur: ${navigator.userAgent.substring(0, 50)}...`;
                const connectionInfo = `Connexion: ${isConnected ? 'OK' : 'Probl√®me'}`;
                const recognitionStatus = `Reconnaissance: ${isListening ? 'Active' : 'Inactive'}`;
                
                // Afficher les infos
                debugContent.innerHTML = `
                    ${browserInfo}<br>
                    ${connectionInfo}<br>
                    ${recognitionStatus}<br>
                    Langue: ${langSelect.value}<br>
                    Errors: ${consecutiveErrors}
                `;
                
                // Mettre √† jour r√©guli√®rement
                setTimeout(updateDebugInfo, 1000);
            }
            
            // Mettre √† jour p√©riodiquement les infos du serveur
            function updateServerInfo() {
                fetch('/server-status')
                    .then(response => response.json())
                    .then(data => {
                        isConnected = true;
                        consecutiveErrors = 0;
                        updateConnectionStatus(true);
                        
                        if (data.mode === 'ngrok') {
                            serverModeInfo.innerHTML = 'Mode: Tunnel ngrok';
                        } else {
                            serverModeInfo.innerHTML = 'Mode: Connexion directe';
                        }
                    })
                    .catch(error => {
                        console.error('Erreur:', error);
                        consecutiveErrors++;
                        
                        if (consecutiveErrors > 3) {
                            isConnected = false;
                            updateConnectionStatus(false);
                        }
                        
                        serverModeInfo.textContent = 'Erreur de connexion';
                    });
            }
            
            // Fonction pour mettre √† jour l'indication de connexion
            function updateConnectionStatus(connected) {
                if (connected) {
                    connectionStatus.textContent = 'Connect√©';
                    connectionStatus.classList.remove('disconnected');
                    connectionStatus.classList.add('connected');
                } else {
                    connectionStatus.textContent = 'D√©connect√©';
                    connectionStatus.classList.remove('connected');
                    connectionStatus.classList.add('disconnected');
                }
            }
            
            // Mettre √† jour les informations au chargement et p√©riodiquement
            updateServerInfo();
            setInterval(updateServerInfo, 5000);

            // D√©marrer le heartbeat d√®s le chargement de la page
            startHeartbeat();

            // V√©rifier si la reconnaissance vocale est disponible
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                status.textContent = "La reconnaissance vocale n'est pas prise en charge par votre navigateur.";
                micButton.disabled = true;
                return;
            }

            // Initialiser le contexte audio pour visualiser le niveau sonore
            function initAudioContext(stream) {
                try {
                    // Nettoyer les instances pr√©c√©dentes
                    if (audioContext) {
                        audioContext.close();
                    }
                    
                    // Cr√©er un nouvel AudioContext
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(stream);
                    
                    // Configurer l'analyseur
                    analyser.smoothingTimeConstant = 0.8;
                    analyser.fftSize = 1024;
                    
                    // Connecter le microphone √† l'analyseur
                    microphone.connect(analyser);
                    
                    // Activer l'indicateur de niveau
                    micLevelIndicator.classList.add('active');
                    
                    // Cr√©er un processeur pour l'analyse audio en continu
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    
                    // Fonction pour analyser le niveau audio
                    const checkAudioLevel = () => {
                        if (!isListening) {
                            micLevelIndicator.classList.remove('active');
                            return;
                        }
                        
                        // R√©cup√©rer les donn√©es audio
                        analyser.getByteFrequencyData(dataArray);
                        
                        // Calculer la moyenne des fr√©quences
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += dataArray[i];
                        }
                        const average = sum / bufferLength;
                        
                        // Mettre √† jour l'indicateur de niveau
                        const levelPercent = Math.min(average * 2, 100);  // Amplifier pour une meilleure visibilit√©
                        micLevelBar.style.width = levelPercent + '%';
                        
                        // Continuer l'analyse
                        requestAnimationFrame(checkAudioLevel);
                    };
                    
                    // D√©marrer l'analyse
                    requestAnimationFrame(checkAudioLevel);
                    
                } catch (e) {
                    console.warn("Impossible de configurer l'analyse audio:", e);
                }
            }
            
            // Initialiser la reconnaissance vocale
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            // Fonction pour cr√©er une nouvelle instance de reconnaissance vocale en fran√ßais
            function createRecognition() {
                const instance = new SpeechRecognition();
                instance.lang = 'fr-FR';
                instance.continuous = true;
                instance.interimResults = true;
                
                // Gestion des r√©sultats
                instance.onresult = function(event) {
                    const lastResultIndex = event.results.length - 1;
                    const transcript = event.results[lastResultIndex][0].transcript;
                    
                    // Si c'est un r√©sultat final
                    if (event.results[lastResultIndex].isFinal) {
                        finalTranscript = transcript;
                        status.textContent = "Texte reconnu, traduction en cours...";
                        originalText.textContent = finalTranscript;
                        
                        // Effacer tout timeout pr√©c√©dent
                        if (processingTimeout) {
                            clearTimeout(processingTimeout);
                        }
                        
                        // Ajouter un d√©lai pour √©viter les traductions multiples
                        processingTimeout = setTimeout(() => {
                            sendTranslationRequest(finalTranscript);
                        }, 1000);
                    } else {
                        status.textContent = 'En cours: ' + transcript;
                        originalText.textContent = transcript;
                    }
                };
                
                // Gestion des erreurs
                instance.onerror = function(event) {
                    console.error('Erreur de reconnaissance vocale:', event.error);
                    
                    // Ne pas arr√™ter pour les erreurs temporaires
                    if (event.error === 'no-speech') {
                        status.textContent = "Aucune parole d√©tect√©e, continuez √† parler...";
                        return;
                    }
                    
                    status.textContent = "Erreur: " + event.error;
                    
                    // Si probl√®me grave, arr√™ter l'√©coute
                    if (['network', 'not-allowed', 'service-not-allowed'].includes(event.error)) {
                        toggleRecognition(false);
                    }
                };
                
                // Gestion de fin de reconnaissance
                instance.onend = function() {
                    console.log("Reconnaissance termin√©e");
                    
                    // Si toujours en mode d'√©coute, red√©marrer
                    if (isListening) {
                        try {
                            // Cr√©er une nouvelle instance plut√¥t que de r√©utiliser
                            recognition = createRecognition();
                            recognition.start();
                            console.log("Reconnaissance red√©marr√©e");
                        } catch (e) {
                            console.error("Erreur lors du red√©marrage de la reconnaissance:", e);
                            status.textContent = "Impossible de continuer l'√©coute. Veuillez r√©essayer.";
                            toggleRecognition(false);
                        }
                    }
                };
                
                return instance;
            }
            
            // Fonction pour envoyer une requ√™te de traduction au serveur
            function sendTranslationRequest(text) {
                // V√©rifier si le texte est vide
                if (!text || text.trim() === '') {
                    status.textContent = "Texte vide, veuillez r√©essayer.";
                    return;
                }
                
                const targetLang = langSelect.value;
                
                // Ajouter des logs pour le d√©bogage
                if (debugInfo.classList.contains('visible')) {
                    debugContent.innerHTML += `<br>Envoi: "${text.substring(0, 20)}..." vers ${targetLang}`;
                }
                
                fetch('/translate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        lang: targetLang
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    originalText.textContent = data.original;
                    translatedText.textContent = data.translated;
                    
                    // Mettre √† jour l'affichage de la langue
                    targetLangLabel.textContent = getLangNameFromCode(targetLang);
                    
                    // Mettre √† jour le statut
                    status.textContent = "Traduction envoy√©e √† l'ordinateur";
                    
                    // R√©initialiser les erreurs et la connexion
                    isConnected = true;
                    consecutiveErrors = 0;
                    updateConnectionStatus(true);
                    
                    // Ajouter au d√©bogage
                    if (debugInfo.classList.contains('visible')) {
                        debugContent.innerHTML += `<br>Traduit: OK`;
                    }
                })
                .catch(error => {
                    console.error('Erreur lors de la traduction:', error);
                    status.textContent = 'Erreur de traduction. Veuillez r√©essayer.';
                    
                    // Incr√©menter les erreurs
                    consecutiveErrors++;
                    
                    // Si trop d'erreurs, marquer comme d√©connect√©
                    if (consecutiveErrors > 3) {
                        isConnected = false;
                        updateConnectionStatus(false);
                    }
                    
                    // Ajouter au d√©bogage
                    if (debugInfo.classList.contains('visible')) {
                        debugContent.innerHTML += `<br>Erreur: ${error.message}`;
                    }
                });
            }
            
            // Obtenir le nom de la langue √† partir du code
            function getLangNameFromCode(code) {
                const langNames = {
                    'en': 'Anglais',
                    'es': 'Espagnol',
                    'de': 'Allemand',
                    'it': 'Italien',
                    'pt': 'Portugais',
                    'ru': 'Russe',
                    'zh-CN': 'Chinois',
                    'ja': 'Japonais',
                    'ar': 'Arabe',
                    'uk': 'Ukrainien',
                    'fa': 'Persan',
                    'hi': 'Hindi',
                    'bn': 'Bengali',
                    'te': 'T√©lougou',
                    'mr': 'Marathi'
                };
                return langNames[code] || code;
            }
            
            // Fonction pour basculer l'√©tat d'√©coute
            function toggleRecognition(startListening) {
                if (startListening && !isListening) {
                    // V√©rifier l'acc√®s au microphone
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then((stream) => {
                            // Initialiser l'interface audio
                            initAudioContext(stream);
                            
                            // Cr√©er une instance de reconnaissance en fran√ßais
                            recognition = createRecognition();
                            
                            try {
                                recognition.start();
                                isListening = true;
                                micButton.textContent = 'üé§ Arr√™ter';
                                micButton.classList.add('active');
                                status.textContent = '√âcoute en cours...';
                                waveAnimation.classList.add('active');
                                
                                // Ajouter au d√©bogage
                                if (debugInfo.classList.contains('visible')) {
                                    debugContent.innerHTML += `<br>Micro activ√©`;
                                }
                            } catch (error) {
                                console.error("Erreur au d√©marrage de la reconnaissance:", error);
                                status.textContent = "Erreur au d√©marrage de la reconnaissance";
                                
                                // Ajouter au d√©bogage
                                if (debugInfo.classList.contains('visible')) {
                                    debugContent.innerHTML += `<br>Erreur mic: ${error.message}`;
                                }
                            }
                        })
                        .catch(err => {
                            console.error("Erreur d'acc√®s au microphone:", err);
                            status.textContent = "Veuillez autoriser l'acc√®s au microphone.";
                            
                            // Ajouter au d√©bogage
                            if (debugInfo.classList.contains('visible')) {
                                debugContent.innerHTML += `<br>Erreur permission: ${err.message}`;
                            }
                        });
                } else if (!startListening && isListening) {
                    if (recognition) {
                        try {
                            recognition.stop();
                        } catch (e) {
                            console.error("Erreur lors de l'arr√™t de la reconnaissance:", e);
                        }
                    }
                    
                    // Nettoyer les ressources audio
                    if (audioContext) {
                        try {
                            if (microphone) microphone.disconnect();
                            if (analyser) analyser.disconnect();
                        } catch (e) {
                            console.warn("Erreur lors du nettoyage audio:", e);
                        }
                    }
                    
                    isListening = false;
                    micButton.textContent = 'üé§ Parler en Fran√ßais';
                    micButton.classList.remove('active');
                    status.textContent = "Cliquez sur le micro pour parler en fran√ßais";
                    waveAnimation.classList.remove('active');
                    micLevelIndicator.classList.remove('active');
                    
                    // Ajouter au d√©bogage
                    if (debugInfo.classList.contains('visible')) {
                        debugContent.innerHTML += `<br>Micro d√©sactiv√©`;
                    }
                }
            }
            
            // Gestion du clic sur le bouton
            micButton.addEventListener('click', function() {
                toggleRecognition(!isListening);
            });
            
            // FONCTION MODIFI√âE : Syst√®me de polling pour r√©cup√©rer les r√©ponses de l'ordinateur
function startPolling() {
    setInterval(() => {
        fetch('/check-updates', {
            cache: 'no-store'  // √âviter les probl√®mes de mise en cache
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Erreur HTTP: ${response.status}`);
            }
            
            // R√©initialiser les erreurs et la connexion
            isConnected = true;
            consecutiveErrors = 0;
            updateConnectionStatus(true);
            
            return response.json();
        })
        .then(data => {
            console.log("Donn√©es re√ßues du serveur:", data);
            
            // MODIFICATION CL√â : Accepter tous les types de mises √† jour, pas seulement celles avec source_language
            if (data.original && data.translated) {
                // V√©rifier si c'est une traduction du PC vers le t√©l√©phone
                const isPCtoPhone = data.language === 'fr';
                
                console.log("R√©ception d'une mise √† jour:", isPCtoPhone ? "PC vers t√©l√©phone" : "autre type");
                
                // Afficher la r√©ponse dans notre interface
                originalText.textContent = data.original;
                translatedText.textContent = data.translated;
                
                // Mettre √† jour l'affichage de la langue selon le type de traduction
                if (isPCtoPhone && data.source_language) {
                    // PC ‚Üí T√©l√©phone : La source est la langue √©trang√®re, la cible est le fran√ßais
                    const langName = getLangNameFromCode(data.source_language);
                    targetLangLabel.textContent = "Fran√ßais";
                    status.textContent = `Nouvelle r√©ponse en fran√ßais`;
                } else if (data.language && data.language !== 'fr') {
                    // T√©l√©phone ‚Üí PC : La source est le fran√ßais, la cible est la langue √©trang√®re
                    const langName = getLangNameFromCode(data.language);
                    targetLangLabel.textContent = langName;
                }
                
                // Notification visuelle
                status.textContent = "Nouvelle mise √† jour re√ßue";
                setTimeout(() => {
                    status.textContent = "Cliquez sur le micro pour parler en fran√ßais";
                }, 3000);
            }
        })
        .catch(error => {
            console.error('Erreur de polling:', error);
            
            // Incr√©menter les erreurs
            consecutiveErrors++;
            
            // Si trop d'erreurs, marquer comme d√©connect√©
            if (consecutiveErrors > 3) {
                isConnected = false;
                updateConnectionStatus(false);
            }
        });
    }, 2000);  // V√©rifier toutes les 2 secondes
}
            
            // Fonction pour envoyer le heartbeat
            function sendHeartbeat() {
                fetch('/heartbeat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ status: 'active', timestamp: Date.now() })
                })
                .then(response => {
                    // R√©initialiser les erreurs et la connexion si OK
                    if (response.ok) {
                        isConnected = true;
                        consecutiveErrors = 0;
                        updateConnectionStatus(true);
                    }
                })
                .catch(error => {
                    console.error('Erreur de heartbeat:', error);

                    // Incr√©menter les erreurs
                    consecutiveErrors++;
                    
                    // Si trop d'erreurs, marquer comme d√©connect√©
                    if (consecutiveErrors > 3) {
                        isConnected = false;
                        updateConnectionStatus(false);
                    }
                });
            }
            
            // Fonction pour d√©marrer le heartbeat
            function startHeartbeat() {
                // Envoyer un heartbeat imm√©diatement
                sendHeartbeat();
                
                // Puis envoyer un heartbeat toutes les 5 secondes
                heartbeatInterval = setInterval(sendHeartbeat, 5000);
                
                // S'assurer que les pings s'arr√™tent lorsque la page est ferm√©e
                window.addEventListener('beforeunload', function(event) {
                    // Arr√™ter les heartbeats p√©riodiques
                    if (heartbeatInterval) {
                        clearInterval(heartbeatInterval);
                    }
                    
                    // Envoyer une notification de fermeture explicite
                    navigator.sendBeacon('/close', JSON.stringify({ status: 'closing' }));
                });
            }
            
            // V√©rification p√©riodique de la connexion
            setInterval(function() {
                // Si la derni√®re v√©rification est trop ancienne, faire un ping
                const now = Date.now();
                if (now - lastConnectionCheck > 30000) { // 30 secondes
                    sendHeartbeat();
                    lastConnectionCheck = now;
                }
            }, 10000);
            
            // D√©marrer le polling pour r√©cup√©rer les r√©ponses
            startPolling();
            
            // Mettre √† jour la langue affich√©e au chargement
            targetLangLabel.textContent = getLangNameFromCode(langSelect.value);
        });
    </script>
</body>
</html>