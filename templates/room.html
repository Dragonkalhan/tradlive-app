<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradLive - Salle {{ room_id }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .room-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .voice-method-indicator {
            background: rgba(33, 150, 243, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin: 10px 0;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .method-webspeech { background: rgba(76, 175, 80, 0.9); }
        .method-azure { background: rgba(255, 193, 7, 0.9); color: #333; }
        .method-text { background: rgba(244, 67, 54, 0.9); }
        
        .leave-button {
            padding: 8px 16px;
            background: rgba(244, 67, 54, 0.8);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            text-decoration: none;
        }
        
        .qr-section {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .status.connected { background: rgba(76, 175, 80, 0.8); }
        .status.error { background: rgba(244, 67, 54, 0.8); }
        .status.info { background: rgba(33, 150, 243, 0.8); }
        .status.recording { background: rgba(255, 193, 7, 0.8); color: #333; }
        .status.processing { background: rgba(156, 39, 176, 0.8); }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .mic-button {
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 50px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            min-width: 250px;
            position: relative;
            overflow: hidden;
        }
        
        .mic-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .mic-button.recording {
            background: linear-gradient(45deg, #f44336, #da190b);
            animation: pulse 2s infinite;
        }
        
        .mic-button.processing {
            background: linear-gradient(45deg, #9c27b0, #7b1fa2);
            animation: processing 1.5s infinite;
        }
        
        .mic-button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }
        
        @keyframes processing {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .recording-timer {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            display: none;
        }
        
        .mic-button.recording .recording-timer {
            display: block;
        }
        
        .text-mode-button {
            padding: 10px 20px;
            background: rgba(33, 150, 243, 0.8);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        
        .translation-area {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            min-height: 200px;
        }
        
        .translation-section {
            margin-bottom: 20px;
        }
        
        .translation-label {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }
        
        .translation-text {
            font-size: 18px;
            line-height: 1.5;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            min-height: 60px;
            word-wrap: break-word;
            transition: all 0.3s ease;
        }
        
        .translation-text.updating {
            background: rgba(255, 193, 7, 0.3);
            transform: scale(1.02);
        }
        
        .empty-translation {
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        
        .wave-animation {
            display: none;
            justify-content: center;
            align-items: center;
            height: 40px;
            margin: 10px 0;
        }
        
        .wave-animation.active {
            display: flex;
        }
        
        .wave-bar {
            display: inline-block;
            width: 5px;
            background-color: #FFD700;
            margin: 0 3px;
            border-radius: 2px;
            animation: waveAnimation 0.5s infinite alternate;
        }
        
        @keyframes waveAnimation {
            0% { height: 10px; }
            100% { height: 30px; }
        }
        
        .wave-bar:nth-child(1) { animation-delay: 0.1s; }
        .wave-bar:nth-child(2) { animation-delay: 0.2s; }
        .wave-bar:nth-child(3) { animation-delay: 0.3s; }
        .wave-bar:nth-child(4) { animation-delay: 0.4s; }
        .wave-bar:nth-child(5) { animation-delay: 0.3s; }
        
        .text-input-fallback {
            display: none;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 2px solid rgba(33, 150, 243, 0.5);
        }
        
        .text-input-fallback.show {
            display: block;
        }
        
        .text-input-fallback textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: none;
            min-height: 80px;
            margin-bottom: 10px;
            box-sizing: border-box;
            font-size: 16px;
            resize: vertical;
        }
        
        .text-input-fallback button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        
        .confidence-indicator {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .error-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 4px solid #f44336;
            max-width: 300px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .error-notification.show {
            transform: translateX(0);
        }
        
        .browser-info {
            font-size: 12px;
            opacity: 0.8;
            text-align: center;
            margin-top: 10px;
        }
        
        @media (max-width: 600px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .room-info {
                flex-direction: column;
                text-align: center;
            }
            
            .mic-button {
                width: 100%;
                margin: 5px 0;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç TradLive</h1>
            <div class="room-info">
                <div class="room-code">Salle : <span id="room-id">{{ room_id }}</span></div>
                <div class="user-info">
                    <span id="user-nickname">Chargement...</span>
                    <div id="voice-method" class="voice-method-indicator">D√©tection en cours...</div>
                </div>
                <button class="leave-button" onclick="leaveRoom()">üö™ Quitter</button>
            </div>
        </div>
        
        <!-- Section QR Code (visible directement) -->
        <div class="qr-section">
            <p>üì± <strong>Scannez pour rejoindre la salle :</strong></p>
            <img id="qr-image" src="" alt="QR Code" style="max-width: 200px; border-radius: 10px; margin: 10px auto; display: block;">
        </div>
        
        <div id="status" class="status info">Initialisation du syst√®me vocal...</div>
        
        <div id="controls" class="controls">
            <button id="mic-button" class="mic-button" disabled>
                üé§ Initialisation...
                <div class="recording-timer" id="recording-timer">0s</div>
            </button>
            <button id="text-mode-button" class="text-mode-button">üí¨ Mode Texte</button>
            <button id="debug-azure-button" class="text-mode-button" style="background: rgba(255, 152, 0, 0.8);" onclick="debugAzure()">üîß Test Azure</button>
            
            <div class="wave-animation" id="wave-animation">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>
            
            <div id="text-input-fallback" class="text-input-fallback">
                <h4 id="text-input-title">‚úçÔ∏è Saisie de texte</h4>
                <textarea id="text-input" placeholder="√âcrivez votre message ici..."></textarea>
                <button onclick="sendText()">üì§ Envoyer</button>
                <button onclick="hideTextInput()">‚ùå Fermer</button>
                <button onclick="tryVoiceAgain()">üé§ R√©essayer le micro</button>
            </div>
            
            <div id="browser-info" class="browser-info"></div>
        </div>
        
        <div class="translation-area">
            <div class="translation-section">
                <div class="translation-label">üìù Message original</div>
                <div id="original-text" class="translation-text empty-translation">
                    En attente de votre message...
                </div>
                <div id="confidence-display" class="confidence-indicator" style="display: none;"></div>
            </div>
            
            <div class="translation-section">
                <div class="translation-label">üåç Traduction</div>
                <div id="translated-text" class="translation-text empty-translation">
                    En attente d'une traduction...
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification d'erreur -->
    <div id="error-notification" class="error-notification">
        <div id="error-message"></div>
    </div>
    
    <script>
        // üß† GESTIONNAIRE VOCAL CORRIG√â (WEB SPEECH + AZURE)
        class VoiceManager {
            constructor(options = {}) {
                this.roomId = options.roomId;
                this.userId = options.userId;
                this.language = options.language || 'fr';
                this.isHost = options.isHost || false;
                
                this.onResult = options.onResult || (() => {});
                this.onError = options.onError || (() => {});
                this.onStatusChange = options.onStatusChange || (() => {});
                
                this.speechRecognition = null;
                this.currentMethod = null;
                this.isListening = false;
                this.recordingTimer = null;
                this.recordingStartTime = null;
                this.errorCount = 0; // Protection contre boucles d'erreurs
                this.maxErrors = 3;
                
                this.browserInfo = this.detectBrowser();
                this.azureAvailable = false;
            }
            
            detectBrowser() {
                const ua = navigator.userAgent;
                const isIOS = /iPad|iPhone|iPod/.test(ua);
                const isSafari = ua.includes('Safari') && !ua.includes('Chrome') && !ua.includes('Edge');
                
                let browser = { name: 'unknown', compatibility: 'unknown', method: 'text' };
                
                // iPhone/iPad ‚Üí Toujours mode texte (limitations Apple)
                if (isIOS) {
                    browser = { 
                        name: 'iOS Safari', 
                        compatibility: 'poor', 
                        method: 'text',
                        description: 'Mode Texte (Limitation iOS)',
                        limitation: 'Apple bloque Web Speech et MediaRecorder'
                    };
                }
                // Chrome Desktop/Android ‚Üí Web Speech optimal
                else if (ua.includes('Chrome') && !ua.includes('Edge') && !ua.includes('Brave')) {
                    browser = { 
                        name: 'Chrome', 
                        compatibility: 'excellent', 
                        method: 'webspeech',
                        description: 'Web Speech API (Optimal)' 
                    };
                }
                // Edge Chromium ‚Üí Web Speech optimal
                else if (ua.includes('Edge')) {
                    browser = { 
                        name: 'Edge', 
                        compatibility: 'excellent', 
                        method: 'webspeech',
                        description: 'Web Speech API (Optimal)' 
                    };
                }
                // Brave ‚Üí Web Speech API (corrig√©!)
                else if (ua.includes('Brave')) {
                    browser = { 
                        name: 'Brave', 
                        compatibility: 'good', 
                        method: 'webspeech',
                        description: 'Web Speech API (Brave)' 
                    };
                }
                // Opera (Chromium) ‚Üí Web Speech
                else if (ua.includes('Opera') || ua.includes('OPR')) {
                    browser = { 
                        name: 'Opera', 
                        compatibility: 'good', 
                        method: 'webspeech',
                        description: 'Web Speech API (Opera)' 
                    };
                }
                // Firefox ‚Üí Azure direct (pas de Web Speech)
                else if (ua.includes('Firefox')) {
                    browser = { 
                        name: 'Firefox', 
                        compatibility: 'limited', 
                        method: 'azure',
                        description: 'Azure Speech (Firefox)' 
                    };
                }
                // Safari Desktop ‚Üí Mode texte (bugs Web Speech)
                else if (isSafari) {
                    browser = { 
                        name: 'Safari', 
                        compatibility: 'poor', 
                        method: 'text',
                        description: 'Mode Texte (Bugs Safari)',
                        limitation: 'Web Speech API bugg√©e sur Safari'
                    };
                }
                // Samsung Internet et autres
                else if (ua.includes('Samsung')) {
                    browser = { 
                        name: 'Samsung Internet', 
                        compatibility: 'limited', 
                        method: 'azure',
                        description: 'Azure Speech (Mobile)' 
                    };
                }
                // Navigateurs inconnus ‚Üí Azure puis texte
                else {
                    browser = { 
                        name: 'Navigateur inconnu', 
                        compatibility: 'unknown', 
                        method: 'azure',
                        description: 'Azure Speech (Tentative)' 
                    };
                }
                
                return browser;
            }
            
            async checkAzureAvailability() {
                try {
                    console.log('üîç V√©rification disponibilit√© Azure...');
                    const response = await fetch('/api/speech-status');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('‚úÖ R√©ponse Azure:', data);
                        this.azureAvailable = data.available;
                        if (!data.available) {
                            console.warn('‚ö†Ô∏è Azure non disponible:', data.error || 'Service non configur√©');
                        }
                        return data.available;
                    } else {
                        console.error('‚ùå Erreur v√©rification Azure:', response.status, response.statusText);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Erreur r√©seau Azure:', error);
                    return false;
                }
            }
            
            async selectBestMethod() {
                // V√©rifier Azure d'abord
                await this.checkAzureAvailability();
                
                // iOS ‚Üí Toujours mode texte (limitations Apple)
                if (this.browserInfo.method === 'text' && this.browserInfo.limitation) {
                    return 'text';
                }
                
                // Logique de s√©lection intelligente selon navigateur
                switch (this.browserInfo.method) {
                    case 'webspeech':
                        // Chrome/Edge/Opera/Brave ‚Üí Priorit√© Web Speech
                        if (this.isWebSpeechSupported()) {
                            return 'webspeech';
                        } else if (this.azureAvailable) {
                            return 'azure';
                        }
                        break;
                        
                    case 'azure':
                        // Firefox/Samsung ‚Üí Priorit√© Azure
                        if (this.azureAvailable) {
                            return 'azure';
                        } else if (this.isWebSpeechSupported()) {
                            return 'webspeech';
                        }
                        break;
                        
                    case 'text':
                    default:
                        // Safari/iOS ‚Üí Mode texte obligatoire
                        return 'text';
                }
                
                // Fallback final
                return 'text';
            }
            
            isWebSpeechSupported() {
                return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
            }
            
            async initialize() {
                const method = await this.selectBestMethod();
                this.currentMethod = method;
                
                try {
                    switch (method) {
                        case 'webspeech':
                            this.initializeWebSpeech();
                            break;
                        case 'azure':
                            // Azure ne n√©cessite pas d'initialisation c√¥t√© client
                            break;
                        default:
                            this.onStatusChange('text', 'Mode texte activ√©');
                            break;
                    }
                    return method;
                } catch (error) {
                    console.error('Erreur initialisation:', error);
                    this.currentMethod = 'text';
                    this.onStatusChange('text', 'Mode texte activ√© (erreur init)');
                    return 'text';
                }
            }
            
            initializeWebSpeech() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                this.speechRecognition = new SpeechRecognition();
                this.speechRecognition.lang = this.language === 'fr' ? 'fr-FR' : `${this.language}-${this.language.toUpperCase()}`;
                this.speechRecognition.continuous = false;
                this.speechRecognition.interimResults = false;
                this.speechRecognition.maxAlternatives = 1;
                
                this.speechRecognition.onstart = () => {
                    this.onStatusChange('recording', '√âcoute en cours...');
                    this.errorCount = 0; // Reset compteur d'erreurs
                };
                
                this.speechRecognition.onresult = (event) => {
                    const lastResult = event.results[event.results.length - 1];
                    const transcript = lastResult[0].transcript.trim();
                    const confidence = lastResult[0].confidence || 0.9;
                    
                    if (transcript) {
                        this.onResult({ 
                            text: transcript, 
                            confidence: confidence,
                            service: 'webspeech'
                        });
                        this.onStatusChange('success', 'Reconnaissance r√©ussie');
                        this.errorCount = 0; // Reset apr√®s succ√®s
                    }
                };
                
                this.speechRecognition.onerror = (event) => {
                    this.errorCount++;
                    let errorMsg = 'Erreur Web Speech: ';
                    
                    switch (event.error) {
                        case 'network':
                            errorMsg += 'Probl√®me r√©seau';
                            if (this.azureAvailable && this.errorCount < this.maxErrors) {
                                errorMsg += ' - basculement vers Azure';
                                this.fallbackToAzure();
                                return;
                            }
                            break;
                        case 'not-allowed':
                            errorMsg += 'Microphone non autoris√©';
                            break;
                        case 'no-speech':
                            errorMsg += 'Aucune parole d√©tect√©e';
                            break;
                        default:
                            errorMsg += event.error;
                    }
                    
                    // √âviter les boucles d'erreurs
                    if (this.errorCount >= this.maxErrors) {
                        errorMsg += ' (passage en mode texte)';
                        this.currentMethod = 'text';
                        this.onStatusChange('text', 'Mode texte activ√© apr√®s erreurs');
                    }
                    
                    this.onError(errorMsg);
                };
                
                this.speechRecognition.onend = () => {
                    this.isListening = false;
                    this.stopRecordingTimer();
                };
            }
            
            async fallbackToAzure() {
                if (this.azureAvailable && this.errorCount < this.maxErrors) {
                    this.currentMethod = 'azure';
                    this.onStatusChange('info', 'Basculement vers Azure Speech...');
                    // R√©essayer automatiquement avec Azure
                    setTimeout(() => {
                        if (!this.isListening) {
                            this.startListening();
                        }
                    }, 1000);
                } else {
                    this.currentMethod = 'text';
                    this.onStatusChange('text', 'Mode texte activ√©');
                }
            }
            
            async startListening() {
                if (this.isListening) return;
                
                // Protection contre trop d'erreurs
                if (this.errorCount >= this.maxErrors) {
                    this.onError('Trop d\'erreurs - utilisez le mode texte');
                    return;
                }
                
                this.isListening = true;
                
                switch (this.currentMethod) {
                    case 'webspeech':
                        if (this.speechRecognition) {
                            try {
                                this.speechRecognition.start();
                                this.startRecordingTimer();
                            } catch (error) {
                                this.onError('Erreur Web Speech: ' + error.message);
                                this.isListening = false;
                                this.errorCount++;
                            }
                        }
                        break;
                        
                    case 'azure':
                        await this.startAzureRecording();
                        break;
                        
                    default:
                        this.onStatusChange('text', 'Utilisez le mode texte');
                        this.isListening = false;
                        break;
                }
            }
            
            async startAzureRecording() {
                try {
                    this.onStatusChange('recording', 'Enregistrement pour Azure...');
                    this.startRecordingTimer();
                    
                    // Obtenir l'acc√®s au microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });
                    
                    // Configuration MediaRecorder
                    const options = {
                        mimeType: this.getSupportedMimeType(),
                        audioBitsPerSecond: 128000
                    };
                    
                    this.mediaRecorder = new MediaRecorder(stream, options);
                    this.audioChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        this.processAzureRecording();
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    this.mediaRecorder.start(1000);
                    
                    // Auto-stop apr√®s 30 secondes
                    setTimeout(() => {
                        if (this.isListening && this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            this.stopListening();
                        }
                    }, 30000);
                    
                } catch (error) {
                    this.onError('Erreur Azure: ' + error.message);
                    this.isListening = false;
                    this.stopRecordingTimer();
                    this.errorCount++;
                }
            }
            
            getSupportedMimeType() {
                const types = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/mp4',
                    'audio/wav'
                ];
                
                for (const type of types) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        return type;
                    }
                }
                return 'audio/wav';
            }
            
            async processAzureRecording() {
                if (!this.audioChunks || this.audioChunks.length === 0) {
                    this.onError('Aucune donn√©e audio enregistr√©e');
                    return;
                }
                
                try {
                    this.onStatusChange('processing', 'Envoi vers Azure...');
                    
                    const audioBlob = new Blob(this.audioChunks, { 
                        type: this.getSupportedMimeType() 
                    });
                    
                    console.log('üì§ Envoi Azure - Taille blob:', audioBlob.size, 'bytes');
                    console.log('üì§ Envoi Azure - Type MIME:', audioBlob.type);
                    console.log('üì§ Envoi Azure - Room ID:', this.roomId);
                    console.log('üì§ Envoi Azure - User ID:', this.userId);
                    
                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'recording.wav');
                    formData.append('language', this.language);
                    formData.append('room_id', this.roomId);
                    formData.append('user_id', this.userId);
                    
                    console.log('üì§ Envoi Azure - D√©but requ√™te vers /api/transcribe-audio');
                    
                    const response = await fetch('/api/transcribe-audio', {
                        method: 'POST',
                        body: formData
                    });
                    
                    console.log('üì§ Azure - Status r√©ponse:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        // Tenter de lire le d√©tail de l'erreur
                        let errorDetail = `Status ${response.status}`;
                        try {
                            const errorData = await response.json();
                            errorDetail = errorData.error || errorData.message || errorDetail;
                            console.error('‚ùå D√©tail erreur Azure:', errorData);
                        } catch (e) {
                            const errorText = await response.text();
                            console.error('‚ùå Erreur texte Azure:', errorText);
                            errorDetail = errorText || errorDetail;
                        }
                        throw new Error(`Erreur serveur Azure: ${errorDetail}`);
                    }
                    
                    const data = await response.json();
                    console.log('‚úÖ R√©ponse Azure compl√®te:', data);
                    
                    if (data.success && data.text) {
                        this.onResult({
                            text: data.text,
                            confidence: data.confidence || 0.9,
                            service: 'azure'
                        });
                        this.onStatusChange('success', 'Transcription Azure r√©ussie');
                        this.errorCount = 0; // Reset apr√®s succ√®s
                    } else {
                        throw new Error(data.error || 'Aucun texte d√©tect√© par Azure');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Erreur compl√®te Azure:', error);
                    this.onError('Azure: ' + error.message);
                    this.errorCount++;
                    
                    // Si Azure √©choue syst√©matiquement, proposer Web Speech ou mode texte
                    if (this.errorCount >= 2) {
                        if (this.isWebSpeechSupported()) {
                            this.onError('Azure d√©faillant - basculement vers Web Speech');
                            this.currentMethod = 'webspeech';
                            this.initializeWebSpeech();
                        } else {
                            this.onError('Azure d√©faillant - utilisez le mode texte');
                            this.currentMethod = 'text';
                        }
                    }
                }
            }
            
            stopListening() {
                if (!this.isListening) return;
                
                this.isListening = false;
                this.stopRecordingTimer();
                
                switch (this.currentMethod) {
                    case 'webspeech':
                        if (this.speechRecognition) {
                            this.speechRecognition.stop();
                        }
                        break;
                        
                    case 'azure':
                        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            this.mediaRecorder.stop();
                        }
                        break;
                }
            }
            
            startRecordingTimer() {
                this.recordingStartTime = Date.now();
                const timerEl = document.getElementById('recording-timer');
                let seconds = 0;
                
                this.recordingTimer = setInterval(() => {
                    seconds++;
                    if (timerEl) {
                        timerEl.textContent = `${seconds}s`;
                    }
                }, 1000);
            }
            
            stopRecordingTimer() {
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                    this.recordingTimer = null;
                }
                
                const timerEl = document.getElementById('recording-timer');
                if (timerEl) {
                    timerEl.textContent = '0s';
                }
            }
            
            cleanup() {
                this.stopRecordingTimer();
                
                if (this.speechRecognition) {
                    this.speechRecognition = null;
                }
                
                if (this.mediaRecorder) {
                    this.mediaRecorder = null;
                }
                
                this.isListening = false;
            }
            
            getStatus() {
                return {
                    method: this.currentMethod,
                    isListening: this.isListening,
                    browser: this.browserInfo,
                    azureAvailable: this.azureAvailable,
                    errorCount: this.errorCount
                };
            }
        }
        
        // üöÄ INT√âGRATION DANS L'INTERFACE
        let voiceManager;
        let userData = null; // Sera initialis√© dynamiquement
        let updateInterval;
        let updateErrorCount = 0;
        const maxUpdateErrors = 5;
        
        // √âl√©ments DOM
        const statusEl = document.getElementById('status');
        const micButton = document.getElementById('mic-button');
        const textModeButton = document.getElementById('text-mode-button');
        const waveAnimation = document.getElementById('wave-animation');
        const textInputFallback = document.getElementById('text-input-fallback');
        const originalTextEl = document.getElementById('original-text');
        const translatedTextEl = document.getElementById('translated-text');
        const confidenceDisplay = document.getElementById('confidence-display');
        const voiceMethodEl = document.getElementById('voice-method');
        const errorNotification = document.getElementById('error-notification');
        const errorMessage = document.getElementById('error-message');
        const browserInfoEl = document.getElementById('browser-info');
        const userNicknameEl = document.getElementById('user-nickname');
        const qrImageEl = document.getElementById('qr-image');
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeUserData();
            await initializeQRCode();
            await initializeVoiceSystem();
            startRealTimeUpdates();
        });
        
        async function initializeUserData() {
            // R√©cup√©rer les donn√©es utilisateur depuis sessionStorage ou URL
            const roomId = '{{ room_id }}';
            let userId = sessionStorage.getItem('userId');
            let userLang = sessionStorage.getItem('userLang') || 'fr';
            let userNickname = sessionStorage.getItem('userNickname');
            
            // Si pas de donn√©es, r√©cup√©rer depuis l'URL ou cr√©er un utilisateur temporaire
            if (!userId || !userNickname) {
                // G√©n√©rer un ID temporaire
                userId = 'user_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                userNickname = 'Visiteur_' + Math.floor(Math.random() * 1000);
                
                // Sauvegarder temporairement
                sessionStorage.setItem('userId', userId);
                sessionStorage.setItem('userNickname', userNickname);
                sessionStorage.setItem('userLang', userLang);
            }
            
            userData = {
                room_id: roomId,
                user_id: userId,
                language: userLang,
                nickname: userNickname
            };
            
            updateUserDisplay();
        }
        
        async function initializeQRCode() {
            // G√©n√©rer l'URL du QR code
            const roomUrl = `${window.location.origin}/room/${userData.room_id}?auto_join=true`;
            const qrUrl = `/qrcode?url=${encodeURIComponent(roomUrl)}`;
            qrImageEl.src = qrUrl;
        }
        
        async function initializeVoiceSystem() {
            voiceManager = new VoiceManager({
                roomId: userData.room_id,
                userId: userData.user_id,
                language: userData.language,
                isHost: true, // √Ä adapter selon votre logique
                onResult: handleVoiceResult,
                onError: handleVoiceError,
                onStatusChange: handleStatusChange
            });
            
            try {
                const method = await voiceManager.initialize();
                updateMethodDisplay(method);
                updateBrowserInfo();
                
                // Messages d'initialisation selon la m√©thode
                switch (method) {
                    case 'text':
                        showTextInput();
                        updateStatus('üí¨ Mode texte activ√©', 'info');
                        break;
                        
                    case 'azure':
                        micButton.disabled = false;
                        micButton.textContent = 'üé§ Parler (Azure)';
                        updateStatus('‚òÅÔ∏è Azure Speech pr√™t', 'connected');
                        break;
                        
                    case 'webspeech':
                        micButton.disabled = false;
                        micButton.textContent = 'üé§ Parler';
                        updateStatus('‚úÖ Web Speech pr√™t', 'connected');
                        break;
                        
                    default:
                        showTextInput();
                        updateStatus('üí¨ Mode texte par d√©faut', 'info');
                }
                
            } catch (error) {
                console.error('Erreur init syst√®me vocal:', error);
                showTextInput();
                updateStatus('üí¨ Mode texte (erreur init)', 'error');
                showErrorNotification('Erreur d\'initialisation: ' + error.message);
            }
        }
        
        function updateMethodDisplay(method) {
            const methodNames = {
                'webspeech': 'Web Speech API',
                'azure': 'Azure Speech',
                'text': 'Mode Texte'
            };
            
            const methodClasses = {
                'webspeech': 'method-webspeech',
                'azure': 'method-azure',  
                'text': 'method-text'
            };
            
            voiceMethodEl.textContent = methodNames[method] || method;
            voiceMethodEl.className = `voice-method-indicator ${methodClasses[method] || ''}`;
        }
        
        function updateBrowserInfo() {
            const info = voiceManager.browserInfo;
            let infoText = `${info.name} - ${info.description}`;
            
            // Ajouter des avertissements sp√©cifiques
            if (info.limitation) {
                infoText += ` ‚ö†Ô∏è`;
                showBrowserLimitation(info.limitation);
            }
            
            browserInfoEl.textContent = infoText;
        }
        
        function showBrowserLimitation(limitation) {
            // Afficher une notification discr√®te sur les limitations
            const limitationDiv = document.createElement('div');
            limitationDiv.style.cssText = `
                background: rgba(255, 193, 7, 0.8);
                color: #333;
                padding: 10px;
                border-radius: 8px;
                margin: 10px 0;
                font-size: 14px;
                text-align: center;
            `;
            limitationDiv.textContent = `‚ÑπÔ∏è ${limitation}`;
            
            // L'ins√©rer temporairement
            const controls = document.getElementById('controls');
            controls.insertBefore(limitationDiv, controls.firstChild);
            
            // Retirer apr√®s 10 secondes
            setTimeout(() => {
                if (limitationDiv.parentNode) {
                    limitationDiv.remove();
                }
            }, 10000);
        }
        
        function updateUserDisplay() {
            userNicknameEl.textContent = userData.nickname;
        }
        
        function handleVoiceResult(result) {
            console.log('R√©sultat vocal:', result);
            
            // Afficher le texte original avec animation
            originalTextEl.classList.add('updating');
            originalTextEl.textContent = result.text;
            originalTextEl.classList.remove('empty-translation');
            
            setTimeout(() => {
                originalTextEl.classList.remove('updating');
            }, 300);
            
            // Afficher la confiance et le service
            if (result.confidence && result.confidence < 1) {
                confidenceDisplay.textContent = `Confiance: ${Math.round(result.confidence * 100)}% (${result.service})`;
                confidenceDisplay.style.display = 'block';
            } else {
                confidenceDisplay.style.display = 'none';
            }
            
            // Envoyer √† votre API de traduction
            sendForTranslation(result.text);
        }
        
        function handleVoiceError(error) {
            console.error('Erreur vocale:', error);
            showErrorNotification(error);
            
            // Auto-basculement vers mode texte apr√®s erreurs critiques
            if (error.includes('Microphone non autoris√©') || error.includes('Trop d\'erreurs')) {
                setTimeout(() => {
                    showTextInput();
                }, 2000);
            }
        }
        
        function handleStatusChange(status, message) {
            updateStatus(message, status);
            updateButtonState(status);
        }
        
        function updateStatus(message, className) {
            statusEl.textContent = message;
            statusEl.className = `status ${className}`;
        }
        
        function updateButtonState(status) {
            micButton.classList.remove('recording', 'processing');
            waveAnimation.classList.remove('active');
            
            switch (status) {
                case 'recording':
                    micButton.classList.add('recording');
                    micButton.textContent = 'üõë Arr√™ter';
                    waveAnimation.classList.add('active');
                    break;
                case 'processing':
                case 'uploading':
                    micButton.classList.add('processing');
                    micButton.textContent = '‚è≥ Traitement...';
                    micButton.disabled = true;
                    setTimeout(() => {
                        // Protection contre blocage infini
                        if (micButton.textContent === '‚è≥ Traitement...') {
                            micButton.textContent = 'üé§ Parler';
                            micButton.disabled = false;
                            micButton.classList.remove('processing');
                        }
                    }, 10000);
                    break;
                case 'success':
                case 'connected':
                case 'info':
                default:
                    micButton.textContent = 'üé§ Parler';
                    micButton.disabled = false;
                    break;
            }
        }
        
        function showErrorNotification(message) {
            errorMessage.textContent = message;
            errorNotification.classList.add('show');
            
            setTimeout(() => {
                errorNotification.classList.remove('show');
            }, 5000);
        }
        
        async function sendForTranslation(text) {
            try {
                updateStatus('üì§ Envoi de la traduction...', 'info');
                
                const response = await fetch(`/api/room/${userData.room_id}/translate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userData.user_id,
                        text: text,
                        source_language: userData.language
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        updateStatus('‚úÖ Message envoy√©', 'connected');
                    } else {
                        throw new Error(data.error);
                    }
                } else {
                    throw new Error('Erreur serveur de traduction');
                }
                
            } catch (error) {
                updateStatus('‚ùå Erreur de traduction', 'error');
                showErrorNotification('Erreur lors de l\'envoi: ' + error.message);
            }
        }
        
        // Event listeners
        micButton.addEventListener('click', function() {
            if (voiceManager.isListening) {
                voiceManager.stopListening();
            } else {
                voiceManager.startListening();
            }
        });
        
        textModeButton.addEventListener('click', showTextInput);
        
        function showTextInput() {
            textInputFallback.classList.add('show');
            document.getElementById('text-input').focus();
        }
        
        function hideTextInput() {
            textInputFallback.classList.remove('show');
        }
        
        function sendText() {
            const text = document.getElementById('text-input').value.trim();
            if (text) {
                handleVoiceResult({ text: text, confidence: 1, service: 'manual' });
                document.getElementById('text-input').value = '';
                hideTextInput();
            }
        }
        
        function tryVoiceAgain() {
            hideTextInput();
            // Reset compteur d'erreurs
            if (voiceManager) {
                voiceManager.errorCount = 0;
            }
            initializeVoiceSystem();
        }
        
        async function debugAzure() {
            updateStatus('üîß Test de configuration Azure...', 'info');
            
            try {
                console.log('üîß === DEBUG AZURE START ===');
                
                // 1. Tester la route de statut Azure
                console.log('üîß Test 1: V√©rification /api/speech-status');
                const statusResponse = await fetch('/api/speech-status');
                console.log('üîß Status response:', statusResponse.status, statusResponse.statusText);
                
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    console.log('üîß Status data:', statusData);
                    
                    if (!statusData.available) {
                        updateStatus('‚ùå Azure non configur√© sur le serveur', 'error');
                        showErrorNotification('Azure Speech Service non configur√©. V√©rifiez les variables AZURE_SPEECH_KEY et AZURE_SPEECH_REGION sur Render.');
                        return;
                    }
                } else {
                    updateStatus('‚ùå Route Azure inaccessible', 'error');
                    showErrorNotification('Route /api/speech-status introuvable. V√©rifiez le d√©ploiement backend.');
                    return;
                }
                
                // 2. Tester l'enregistrement audio
                console.log('üîß Test 2: V√©rification MediaRecorder');
                if (!('MediaRecorder' in window)) {
                    updateStatus('‚ùå MediaRecorder non support√©', 'error');
                    showErrorNotification('Votre navigateur ne supporte pas MediaRecorder. Utilisez Chrome, Firefox ou Edge.');
                    return;
                }
                
                // 3. Tester l'acc√®s microphone
                console.log('üîß Test 3: Test acc√®s microphone');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('üîß Microphone OK');
                    stream.getTracks().forEach(track => track.stop());
                } catch (micError) {
                    updateStatus('‚ùå Microphone inaccessible', 'error');
                    showErrorNotification('Acc√®s microphone refus√©. Autorisez le microphone dans votre navigateur.');
                    console.error('üîß Erreur microphone:', micError);
                    return;
                }
                
                // 4. Test Azure avec audio factice
                console.log('üîß Test 4: Test Azure avec donn√©es factices');
                const fakeBlob = new Blob(['fake audio data'], { type: 'audio/wav' });
                const formData = new FormData();
                formData.append('audio', fakeBlob, 'test.wav');
                formData.append('language', 'fr');
                formData.append('room_id', userData.room_id);
                formData.append('user_id', userData.user_id);
                
                const testResponse = await fetch('/api/transcribe-audio', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('üîß Test Azure response:', testResponse.status, testResponse.statusText);
                
                if (testResponse.ok) {
                    const testData = await testResponse.json();
                    console.log('üîß Test Azure data:', testData);
                    updateStatus('‚úÖ Configuration Azure OK', 'connected');
                    showErrorNotification('Azure fonctionne ! Le probl√®me vient peut-√™tre du format audio.');
                } else {
                    const errorText = await testResponse.text();
                    console.error('üîß Erreur test Azure:', errorText);
                    updateStatus('‚ùå Azure √©choue', 'error');
                    showErrorNotification('Azure retourne erreur 500. V√©rifiez les logs Render et la configuration Azure.');
                }
                
                console.log('üîß === DEBUG AZURE END ===');
                
            } catch (error) {
                console.error('üîß Erreur debug Azure:', error);
                updateStatus('‚ùå Erreur debug Azure', 'error');
                showErrorNotification('Erreur pendant le debug: ' + error.message);
            }
        }
        
        function leaveRoom() {
            if (confirm('Quitter la salle ?')) {
                if (voiceManager) voiceManager.cleanup();
                if (updateInterval) clearInterval(updateInterval);
                window.location.href = '/rooms';
            }
        }
        
        function startRealTimeUpdates() {
            updateInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/room/${userData.room_id}/updates?user_id=${userData.user_id}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.translated) {
                            // Afficher la nouvelle traduction
                            translatedTextEl.classList.add('updating');
                            translatedTextEl.textContent = data.translated;
                            translatedTextEl.classList.remove('empty-translation');
                            
                            setTimeout(() => {
                                translatedTextEl.classList.remove('updating');
                            }, 300);
                            
                            // Synth√®se vocale si activ√©e
                            if (data.enable_speech && data.translated) {
                                speakText(data.translated);
                            }
                        }
                        updateErrorCount = 0; // Reset apr√®s succ√®s
                    } else if (response.status === 403) {
                        // Utilisateur non autoris√© - arr√™ter les mises √† jour
                        console.log('Utilisateur non autoris√© - arr√™t des mises √† jour');
                        clearInterval(updateInterval);
                    }
                } catch (error) {
                    updateErrorCount++;
                    console.log('Erreur mise √† jour:', error);
                    
                    // Arr√™ter apr√®s trop d'erreurs pour √©viter les boucles
                    if (updateErrorCount >= maxUpdateErrors) {
                        console.log('Trop d\'erreurs de mise √† jour - arr√™t');
                        clearInterval(updateInterval);
                    }
                }
            }, 3000);
        }
        
        function speakText(text) {
            try {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = userData.language === 'fr' ? 'fr-FR' : `${userData.language}-${userData.language.toUpperCase()}`;
                    utterance.rate = 0.9;
                    utterance.pitch = 1;
                    speechSynthesis.speak(utterance);
                }
            } catch (error) {
                console.log('Erreur synth√®se vocale:', error);
            }
        }
        
        // Gestion Entr√©e pour envoyer
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                if (document.getElementById('text-input') === document.activeElement) {
                    e.preventDefault();
                    sendText();
                }
            }
        });
        
        // Nettoyage √† la fermeture
        window.addEventListener('beforeunload', function() {
            if (voiceManager) voiceManager.cleanup();
            if (updateInterval) clearInterval(updateInterval);
        });
        
        // Heartbeat pour maintenir la session
        setInterval(() => {
            if (userData) {
                fetch(`/api/room/${userData.room_id}/heartbeat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: userData.user_id })
                }).catch(err => console.log('Heartbeat error:', err));
            }
        }, 15000);
    </script>
</body>
</html>
