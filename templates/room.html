<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradLive - Salle {{ room_id }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .room-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .voice-method-indicator {
            background: rgba(33, 150, 243, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin: 10px 0;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .method-webspeech { background: rgba(76, 175, 80, 0.9); }
        .method-azure { background: rgba(255, 193, 7, 0.9); color: #333; }
        .method-text { background: rgba(244, 67, 54, 0.9); }
        
        .leave-button {
            padding: 8px 16px;
            background: rgba(244, 67, 54, 0.8);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            text-decoration: none;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .status.connected { background: rgba(76, 175, 80, 0.8); }
        .status.error { background: rgba(244, 67, 54, 0.8); }
        .status.info { background: rgba(33, 150, 243, 0.8); }
        .status.recording { background: rgba(255, 193, 7, 0.8); color: #333; }
        .status.processing { background: rgba(156, 39, 176, 0.8); }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .mic-button {
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 50px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            min-width: 250px;
            position: relative;
            overflow: hidden;
        }
        
        .mic-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .mic-button.recording {
            background: linear-gradient(45deg, #f44336, #da190b);
            animation: pulse 2s infinite;
        }
        
        .mic-button.processing {
            background: linear-gradient(45deg, #9c27b0, #7b1fa2);
            animation: processing 1.5s infinite;
        }
        
        .mic-button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }
        
        @keyframes processing {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .recording-timer {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            display: none;
        }
        
        .mic-button.recording .recording-timer {
            display: block;
        }
        
        .text-mode-button {
            padding: 10px 20px;
            background: rgba(33, 150, 243, 0.8);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        
        .translation-area {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            min-height: 200px;
        }
        
        .translation-section {
            margin-bottom: 20px;
        }
        
        .translation-label {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }
        
        .translation-text {
            font-size: 18px;
            line-height: 1.5;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            min-height: 60px;
            word-wrap: break-word;
            transition: all 0.3s ease;
        }
        
        .translation-text.updating {
            background: rgba(255, 193, 7, 0.3);
            transform: scale(1.02);
        }
        
        .empty-translation {
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        
        .wave-animation {
            display: none;
            justify-content: center;
            align-items: center;
            height: 40px;
            margin: 10px 0;
        }
        
        .wave-animation.active {
            display: flex;
        }
        
        .wave-bar {
            display: inline-block;
            width: 5px;
            background-color: #FFD700;
            margin: 0 3px;
            border-radius: 2px;
            animation: waveAnimation 0.5s infinite alternate;
        }
        
        @keyframes waveAnimation {
            0% { height: 10px; }
            100% { height: 30px; }
        }
        
        .wave-bar:nth-child(1) { animation-delay: 0.1s; }
        .wave-bar:nth-child(2) { animation-delay: 0.2s; }
        .wave-bar:nth-child(3) { animation-delay: 0.3s; }
        .wave-bar:nth-child(4) { animation-delay: 0.4s; }
        .wave-bar:nth-child(5) { animation-delay: 0.3s; }
        
        .text-input-fallback {
            display: none;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 2px solid rgba(33, 150, 243, 0.5);
        }
        
        .text-input-fallback.show {
            display: block;
        }
        
        .text-input-fallback textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: none;
            min-height: 80px;
            margin-bottom: 10px;
            box-sizing: border-box;
            font-size: 16px;
            resize: vertical;
        }
        
        .text-input-fallback button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        
        .confidence-indicator {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .error-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 4px solid #f44336;
            max-width: 300px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .error-notification.show {
            transform: translateX(0);
        }
        
        .browser-info {
            font-size: 12px;
            opacity: 0.8;
            text-align: center;
            margin-top: 10px;
        }
        
        @media (max-width: 600px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .room-info {
                flex-direction: column;
                text-align: center;
            }
            
            .mic-button {
                width: 100%;
                margin: 5px 0;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç TradLive</h1>
            <div class="room-info">
                <div class="room-code">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <img id="qr-image" src="" alt="QR Code" style="width: 60px; height: 60px; border-radius: 8px; display: none;">
                        <div>
                            <div style="font-size: 16px; font-weight: bold;">Salle : <span id="room-id">{{ room_id }}</span></div>
                            <div id="qr-caption" style="font-size: 12px; opacity: 0.8; margin-top: 5px; display: none;">üì± Scannez le QR code pour rejoindre</div>
                        </div>
                    </div>
                </div>
                <div class="user-info">
                    <span id="user-nickname">Chargement...</span>
                    <div id="voice-method" class="voice-method-indicator">D√©tection en cours...</div>
                </div>
                <button class="leave-button" onclick="leaveRoom()">üö™ Quitter</button>
            </div>
        </div>
        
        <div id="status" class="status info">Initialisation du syst√®me vocal...</div>
        
        <div id="controls" class="controls">
            <button id="mic-button" class="mic-button" disabled>
                üé§ Initialisation...
                <div class="recording-timer" id="recording-timer">0s</div>
            </button>
            <button id="text-mode-button" class="text-mode-button">üí¨ Mode Texte</button>
            <button id="debug-azure-button" class="text-mode-button" style="background: rgba(255, 152, 0, 0.8); display: none;" onclick="debugAzure()">üîß Test Azure</button>
            
            <div id="audio-info" class="browser-info" style="margin-top: 15px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; font-size: 11px;">
                <div>üì± <strong>Strat√©gie audio intelligente :</strong></div>
                <div>‚Ä¢ <strong>Web Speech API :</strong> WebM/Opus (petit, rapide)</div>
                <div>‚Ä¢ <strong>Azure Speech :</strong> WAV (compatible, qualit√©)</div>
                <div>‚Ä¢ <strong>Qualit√© vocale :</strong> Identique pour reconnaissance</div>
            </div>
            
            <div class="wave-animation" id="wave-animation">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>
            
            <div id="text-input-fallback" class="text-input-fallback">
                <h4 id="text-input-title">‚úçÔ∏è Saisie de texte</h4>
                <textarea id="text-input" placeholder="√âcrivez votre message ici..."></textarea>
                <button onclick="sendText()">üì§ Envoyer</button>
                <button onclick="hideTextInput()">‚ùå Fermer</button>
                <button onclick="tryVoiceAgain()">üé§ R√©essayer le micro</button>
            </div>
            
            <div id="browser-info" class="browser-info"></div>
        </div>
        
        <div class="translation-area">
            <div class="translation-section">
                <div class="translation-label">üìù Message original</div>
                <div id="original-text" class="translation-text empty-translation">
                    En attente de votre message...
                </div>
                <div id="confidence-display" class="confidence-indicator" style="display: none;"></div>
            </div>
            
            <div class="translation-section">
                <div class="translation-label">üåç Traduction</div>
                <div id="translated-text" class="translation-text empty-translation">
                    En attente d'une traduction...
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification d'erreur -->
    <div id="error-notification" class="error-notification">
        <div id="error-message"></div>
    </div>
    
    <script>
        // üß† GESTIONNAIRE VOCAL CORRIG√â (WEB SPEECH + AZURE)
        class VoiceManager {
            constructor(options = {}) {
                this.roomId = options.roomId;
                this.userId = options.userId;
                this.language = options.language || 'fr';
                this.isHost = options.isHost || false;
                
                this.onResult = options.onResult || (() => {});
                this.onError = options.onError || (() => {});
                this.onStatusChange = options.onStatusChange || (() => {});
                
                this.speechRecognition = null;
                this.currentMethod = null;
                this.isListening = false;
                this.recordingTimer = null;
                this.recordingStartTime = null;
                this.errorCount = 0; // Protection contre boucles d'erreurs
                this.maxErrors = 3;
                
                this.browserInfo = this.detectBrowser();
                this.azureAvailable = false;
            }
            
            detectBrowser() {
                const ua = navigator.userAgent;
                console.log('üîç User Agent d√©tect√©:', ua);
                
                let browser = { name: 'unknown', compatibility: 'unknown', method: 'text' };
                
                if (ua.includes('Chrome') && !ua.includes('Edge') && !ua.includes('Brave')) {
                    browser = { 
                        name: 'Chrome', 
                        compatibility: 'excellent', 
                        method: 'webspeech',
                        description: 'Web Speech API (Chrome)' 
                    };
                } else if (ua.includes('Brave')) {
                    browser = { 
                        name: 'Brave', 
                        compatibility: 'good', 
                        method: 'webspeech',
                        description: 'Web Speech API (Brave)' 
                    };
                } else if (ua.includes('Edge')) {
                    browser = { 
                        name: 'Edge', 
                        compatibility: 'excellent', 
                        method: 'webspeech',
                        description: 'Web Speech API (Edge)' 
                    };
                } else if (ua.includes('Opera') || ua.includes('OPR')) {
                    browser = { 
                        name: 'Opera', 
                        compatibility: 'good', 
                        method: 'webspeech',
                        description: 'Web Speech API (Opera)' 
                    };
                } else if (ua.includes('Firefox')) {
                    browser = { 
                        name: 'Firefox', 
                        compatibility: 'limited', 
                        method: 'azure',
                        description: 'Azure Speech (Firefox)' 
                    };
                } else if (ua.includes('Safari')) {
                    browser = { 
                        name: 'Safari', 
                        compatibility: 'poor', 
                        method: 'text',
                        description: 'Mode Texte (Safari)' 
                    };
                }
                
                console.log('üåê Navigateur d√©tect√©:', browser);
                return browser;
            }
            
            async checkAzureAvailability() {
                try {
                    console.log('üîç V√©rification disponibilit√© Azure...');
                    const response = await fetch('/api/speech-status');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('‚úÖ R√©ponse Azure:', data);
                        this.azureAvailable = data.available;
                        if (!data.available) {
                            console.warn('‚ö†Ô∏è Azure non disponible:', data.error || 'Service non configur√©');
                        }
                        return data.available;
                    } else {
                        console.error('‚ùå Erreur v√©rification Azure:', response.status, response.statusText);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Erreur r√©seau Azure:', error);
                    return false;
                }
            }
            
            async selectBestMethod() {
                console.log('üéØ S√©lection de la meilleure m√©thode...');
                
                // V√©rifier Azure d'abord pour les navigateurs qui en ont besoin
                await this.checkAzureAvailability();
                
                // Logique de s√©lection intelligente selon navigateur
                switch (this.browserInfo.method) {
                    case 'webspeech':
                        // Chrome/Edge/Opera/Brave ‚Üí TOUJOURS Web Speech
                        if (this.isWebSpeechSupported()) {
                            console.log('üåê Utilisation Web Speech pour:', this.browserInfo.name);
                            return 'webspeech';
                        } else {
                            console.warn('‚ö†Ô∏è Web Speech non support√© pour', this.browserInfo.name, '- passage en mode texte');
                            return 'text';
                        }
                        
                    case 'azure':
                        // Firefox/Samsung ‚Üí Priorit√© Azure
                        if (this.azureAvailable) {
                            console.log('‚òÅÔ∏è Utilisation Azure pour:', this.browserInfo.name);
                            return 'azure';
                        } else if (this.isWebSpeechSupported()) {
                            console.log('üåê Azure indispo, fallback Web Speech pour:', this.browserInfo.name);
                            return 'webspeech';
                        }
                        break;
                        
                    case 'text':
                    default:
                        // Safari/iOS ‚Üí Mode texte obligatoire
                        console.log('üí¨ Mode texte pour:', this.browserInfo.name);
                        return 'text';
                }
                
                // Fallback final
                console.warn('‚ö†Ô∏è Aucune m√©thode vocale disponible - mode texte');
                return 'text';
            }
            
            isWebSpeechSupported() {
                const hasWebKit = 'webkitSpeechRecognition' in window;
                const hasStandard = 'SpeechRecognition' in window;
                const isSupported = hasWebKit || hasStandard;
                
                console.log('üîç Web Speech Support:', {
                    webkitSpeechRecognition: hasWebKit,
                    SpeechRecognition: hasStandard,
                    supported: isSupported,
                    protocol: location.protocol,
                    hostname: location.hostname
                });
                
                return isSupported;
            }
            
            async initialize() {
                const method = await this.selectBestMethod();
                this.currentMethod = method;
                
                try {
                    switch (method) {
                        case 'webspeech':
                            this.initializeWebSpeech();
                            break;
                        case 'azure':
                            // Azure ne n√©cessite pas d'initialisation c√¥t√© client
                            break;
                        default:
                            this.onStatusChange('text', 'Mode texte activ√©');
                            break;
                    }
                    return method;
                } catch (error) {
                    console.error('Erreur initialisation:', error);
                    this.currentMethod = 'text';
                    this.onStatusChange('text', 'Mode texte activ√© (erreur init)');
                    return 'text';
                }
            }
            
            initializeWebSpeech() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                this.speechRecognition = new SpeechRecognition();
                this.speechRecognition.lang = this.language === 'fr' ? 'fr-FR' : `${this.language}-${this.language.toUpperCase()}`;
                this.speechRecognition.continuous = false;
                this.speechRecognition.interimResults = false;
                this.speechRecognition.maxAlternatives = 1;
                
                this.speechRecognition.onstart = () => {
                    this.onStatusChange('recording', '√âcoute en cours...');
                    this.errorCount = 0; // Reset compteur d'erreurs
                };
                
                this.speechRecognition.onresult = (event) => {
                    const lastResult = event.results[event.results.length - 1];
                    const transcript = lastResult[0].transcript.trim();
                    const confidence = lastResult[0].confidence || 0.9;
                    
                    if (transcript) {
                        this.onResult({ 
                            text: transcript, 
                            confidence: confidence,
                            service: 'webspeech'
                        });
                        this.onStatusChange('success', 'Reconnaissance r√©ussie');
                        this.errorCount = 0; // Reset apr√®s succ√®s
                    }
                };
                
                this.speechRecognition.onerror = (event) => {
                    this.errorCount++;
                    let errorMsg = 'Erreur Web Speech: ';
                    
                    switch (event.error) {
                        case 'network':
                            errorMsg += 'Probl√®me r√©seau';
                            // Pour les navigateurs Chromium (Chrome/Brave/Edge), ne pas basculer vers Azure
                            if (this.browserInfo.name === 'Chrome' || this.browserInfo.name === 'Brave' || this.browserInfo.name === 'Edge') {
                                errorMsg += ' - r√©essayez ou utilisez le mode texte';
                            } else if (this.azureAvailable && this.errorCount < this.maxErrors) {
                                errorMsg += ' - basculement vers Azure';
                                this.fallbackToAzure();
                                return;
                            }
                            break;
                        case 'not-allowed':
                            errorMsg += 'Microphone non autoris√©';
                            break;
                        case 'no-speech':
                            errorMsg += 'Aucune parole d√©tect√©e';
                            break;
                        default:
                            errorMsg += event.error;
                    }
                    
                    // √âviter les boucles d'erreurs
                    if (this.errorCount >= this.maxErrors) {
                        errorMsg += ' (passage en mode texte)';
                        this.currentMethod = 'text';
                        this.onStatusChange('text', 'Mode texte activ√© apr√®s erreurs');
                    }
                    
                    this.onError(errorMsg);
                };
                
                this.speechRecognition.onend = () => {
                    this.isListening = false;
                    this.stopRecordingTimer();
                };
            }
            
            async fallbackToAzure() {
                if (this.azureAvailable && this.errorCount < this.maxErrors) {
                    this.currentMethod = 'azure';
                    this.onStatusChange('info', 'Basculement vers Azure Speech...');
                    // R√©essayer automatiquement avec Azure
                    setTimeout(() => {
                        if (!this.isListening) {
                            this.startListening();
                        }
                    }, 1000);
                } else {
                    this.currentMethod = 'text';
                    this.onStatusChange('text', 'Mode texte activ√©');
                }
            }
            
            async startListening() {
                if (this.isListening) return;
                
                // Protection contre trop d'erreurs
                if (this.errorCount >= this.maxErrors) {
                    this.onError('Trop d\'erreurs - utilisez le mode texte');
                    return;
                }
                
                this.isListening = true;
                
                switch (this.currentMethod) {
                    case 'webspeech':
                        if (this.speechRecognition) {
                            try {
                                // V√©rifier les permissions microphone d'abord
                                console.log('üé§ Demande permission microphone...');
                                await navigator.mediaDevices.getUserMedia({ audio: true })
                                    .then(stream => {
                                        console.log('‚úÖ Permission microphone accord√©e');
                                        stream.getTracks().forEach(track => track.stop()); // Arr√™ter le stream de test
                                    });
                                
                                console.log('üé§ D√©marrage Web Speech Recognition...');
                                this.speechRecognition.start();
                                this.startRecordingTimer();
                            } catch (error) {
                                console.error('‚ùå Erreur Web Speech startup:', error);
                                this.onError('Erreur Web Speech: ' + error.message);
                                this.isListening = false;
                                this.errorCount++;
                            }
                        }
                        break;
                        
                    case 'azure':
                        await this.startAzureRecording();
                        break;
                        
                    default:
                        this.onStatusChange('text', 'Utilisez le mode texte');
                        this.isListening = false;
                        break;
                }
            }
            
            async startAzureRecording() {
                try {
                    this.onStatusChange('recording', 'Enregistrement pour Azure...');
                    this.startRecordingTimer();
                    
                    // Obtenir l'acc√®s au microphone avec param√®tres optimis√©s pour Azure
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,  // Azure pr√©f√®re 16kHz
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    // Forcer WAV pour Azure (√©viter INVALID_HEADER)
                    let mimeType = this.getSupportedMimeType(true); // true = pour Azure
                    
                    const options = {
                        mimeType: mimeType,
                        audioBitsPerSecond: mimeType.includes('wav') ? 16000 : 64000  // WAV = moins de compression
                    };
                    
                    console.log('üé§ Configuration MediaRecorder:', options);
                    
                    this.mediaRecorder = new MediaRecorder(stream, options);
                    this.audioChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        this.processAzureRecording();
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    this.mediaRecorder.start(1000);
                    
                    // Auto-stop apr√®s 30 secondes
                    setTimeout(() => {
                        if (this.isListening && this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            this.stopListening();
                        }
                    }, 30000);
                    
                } catch (error) {
                    this.onError('Erreur Azure: ' + error.message);
                    this.isListening = false;
                    this.stopRecordingTimer();
                    this.errorCount++;
                }
            }
            
            getSupportedMimeType(forAzure = false) {
                // Strat√©gie diff√©rente selon la destination
                if (forAzure) {
                    // Pour Azure : WAV prioritaire pour √©viter SPXERR_INVALID_HEADER
                    const azureTypes = [
                        'audio/wav',
                        'audio/mp4',  // Azure supporte aussi MP4
                        'audio/webm;codecs=opus',  // Tenter quand m√™me WebM
                        'audio/webm'
                    ];
                    
                    for (const type of azureTypes) {
                        if (MediaRecorder.isTypeSupported(type)) {
                            console.log('üé§ Format Azure s√©lectionn√©:', type);
                            return type;
                        }
                    }
                } else {
                    // Pour Web Speech : Opus prioritaire (meilleure compression)
                    const webSpeechTypes = [
                        'audio/webm;codecs=opus',
                        'audio/webm',
                        'audio/ogg;codecs=opus',
                        'audio/wav',
                        'audio/mp4'
                    ];
                    
                    for (const type of webSpeechTypes) {
                        if (MediaRecorder.isTypeSupported(type)) {
                            console.log('üé§ Format Web Speech s√©lectionn√©:', type);
                            return type;
                        }
                    }
                }
                
                console.warn('‚ö†Ô∏è Aucun format audio support√©, utilisation par d√©faut');
                return 'audio/wav';
            }
            
            async processAzureRecording() {
                if (!this.audioChunks || this.audioChunks.length === 0) {
                    this.onError('Aucune donn√©e audio enregistr√©e');
                    return;
                }
                
                try {
                    this.onStatusChange('processing', 'Envoi vers Azure...');
                    
                    // Cr√©er le blob avec le bon type MIME
                    let blobType = this.mediaRecorder.mimeType || 'audio/wav';
                    const audioBlob = new Blob(this.audioChunks, { type: blobType });
                    
                    console.log('üì§ Envoi Azure - Taille blob:', audioBlob.size, 'bytes');
                    console.log('üì§ Envoi Azure - Type MIME:', blobType);
                    console.log('üì§ Envoi Azure - Room ID:', this.roomId);
                    console.log('üì§ Envoi Azure - User ID:', this.userId);
                    
                    // Convertir filename selon le format
                    let filename = 'recording.wav';
                    if (blobType.includes('webm')) {
                        filename = 'recording.webm';
                    } else if (blobType.includes('mp4')) {
                        filename = 'recording.mp4';
                    }
                    
                    const formData = new FormData();
                    formData.append('audio', audioBlob, filename);
                    formData.append('language', this.language);
                    formData.append('room_id', this.roomId);
                    formData.append('user_id', this.userId);
                    
                    console.log('üì§ Envoi Azure - D√©but requ√™te vers /api/transcribe-audio');
                    
                    const response = await fetch('/api/transcribe-audio', {
                        method: 'POST',
                        body: formData
                    });
                    
                    console.log('üì§ Azure - Status r√©ponse:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        // Tenter de lire le d√©tail de l'erreur
                        let errorDetail = `Status ${response.status}`;
                        try {
                            const errorData = await response.json();
                            errorDetail = errorData.error || errorData.message || errorDetail;
                            console.error('‚ùå D√©tail erreur Azure:', errorData);
                        } catch (e) {
                            const errorText = await response.text();
                            console.error('‚ùå Erreur texte Azure:', errorText);
                            errorDetail = errorText || errorDetail;
                        }
                        throw new Error(`Erreur serveur Azure: ${errorDetail}`);
                    }
                    
                    const data = await response.json();
                    console.log('‚úÖ R√©ponse Azure compl√®te:', data);
                    
                    if (data.success && data.text) {
                        this.onResult({
                            text: data.text,
                            confidence: data.confidence || 0.9,
                            service: 'azure'
                        });
                        this.onStatusChange('success', 'Transcription Azure r√©ussie');
                        this.errorCount = 0; // Reset apr√®s succ√®s
                    } else {
                        throw new Error(data.error || 'Aucun texte d√©tect√© par Azure');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Erreur compl√®te Azure:', error);
                    this.onError('Azure: ' + error.message);
                    this.errorCount++;
                    
                    // Si Azure √©choue syst√©matiquement, proposer Web Speech ou mode texte
                    if (this.errorCount >= 2) {
                        if (this.isWebSpeechSupported()) {
                            this.onError('Azure d√©faillant - basculement vers Web Speech');
                            this.currentMethod = 'webspeech';
                            this.initializeWebSpeech();
                        } else {
                            this.onError('Azure d√©faillant - utilisez le mode texte');
                            this.currentMethod = 'text';
                        }
                    }
                }
            }
            
            stopListening() {
                if (!this.isListening) return;
                
                this.isListening = false;
                this.stopRecordingTimer();
                
                switch (this.currentMethod) {
                    case 'webspeech':
                        if (this.speechRecognition) {
                            this.speechRecognition.stop();
                        }
                        break;
                        
                    case 'azure':
                        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            this.mediaRecorder.stop();
                        }
                        break;
                }
            }
            
            startRecordingTimer() {
                this.recordingStartTime = Date.now();
                const timerEl = document.getElementById('recording-timer');
                let seconds = 0;
                
                this.recordingTimer = setInterval(() => {
                    seconds++;
                    if (timerEl) {
                        timerEl.textContent = `${seconds}s`;
                    }
                }, 1000);
            }
            
            stopRecordingTimer() {
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                    this.recordingTimer = null;
                }
                
                const timerEl = document.getElementById('recording-timer');
                if (timerEl) {
                    timerEl.textContent = '0s';
                }
            }
            
            cleanup() {
                this.stopRecordingTimer();
                
                if (this.speechRecognition) {
                    this.speechRecognition = null;
                }
                
                if (this.mediaRecorder) {
                    this.mediaRecorder = null;
                }
                
                this.isListening = false;
            }
            
            getStatus() {
                return {
                    method: this.currentMethod,
                    isListening: this.isListening,
                    browser: this.browserInfo,
                    azureAvailable: this.azureAvailable,
                    errorCount: this.errorCount
                };
            }
        }
        
        // üöÄ INT√âGRATION DANS L'INTERFACE
        let voiceManager;
        let userData = null; // Sera initialis√© dynamiquement
        let updateInterval;
        let updateErrorCount = 0;
        const maxUpdateErrors = 5;
        
        // √âl√©ments DOM
        const statusEl = document.getElementById('status');
        const micButton = document.getElementById('mic-button');
        const textModeButton = document.getElementById('text-mode-button');
        const waveAnimation = document.getElementById('wave-animation');
        const textInputFallback = document.getElementById('text-input-fallback');
        const originalTextEl = document.getElementById('original-text');
        const translatedTextEl = document.getElementById('translated-text');
        const confidenceDisplay = document.getElementById('confidence-display');
        const voiceMethodEl = document.getElementById('voice-method');
        const errorNotification = document.getElementById('error-notification');
        const errorMessage = document.getElementById('error-message');
        const browserInfoEl = document.getElementById('browser-info');
        const userNicknameEl = document.getElementById('user-nickname');
        const qrImageEl = document.getElementById('qr-image');
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeUserData(); // Charge les donn√©es de base ET les donn√©es backend
            // QR code sera g√©n√©r√© dans updateUserDisplay() si c'est l'h√¥te
            await initializeVoiceSystem();
            startRealTimeUpdates();
        });
        
        async function initializeUserData() {
            // R√©cup√©rer les donn√©es de base
            const roomId = '{{ room_id }}';
            
            // V√©rifier si c'est un acc√®s via QR code pour rejoindre
            const urlParams = new URLSearchParams(window.location.search);
            const autoJoin = urlParams.get('auto_join');
            
            if (autoJoin === 'true') {
                // Redirection automatique vers la page de join avec room pr√©-remplie
                console.log('üîó Acc√®s via QR code d√©tect√© - redirection vers page de join');
                window.location.href = `/rooms?join=${roomId}`;
                return;
            }
            
            // Essayer de r√©cup√©rer l'utilisateur depuis sessionStorage ou URL
            let userId = sessionStorage.getItem('userId');
            let userLang = sessionStorage.getItem('userLang') || 'fr';
            
            // Si pas d'userId, essayer les param√®tres URL
            if (!userId) {
                userId = urlParams.get('user_id');
                userLang = urlParams.get('lang') || 'fr';
            }
            
            // Initialiser avec les donn√©es de base
            userData = {
                room_id: roomId,
                user_id: userId || 'demo', // Fallback temporaire
                language: userLang,
                nickname: 'Chargement...', // Sera mis √† jour par l'API
                role: 'participant'
            };
            
            console.log('üë§ Donn√©es utilisateur initiales:', userData);
            
            // R√©cup√©rer les vraies donn√©es depuis le backend
            await loadRoomInfo();
        }
        
        async function loadRoomInfo() {
            try {
                console.log('üîç R√©cup√©ration des donn√©es de la room...');
                
                const response = await fetch(`/api/room/${userData.room_id}/info`);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Room n'existe pas
                        showErrorNotification('Cette salle n\'existe pas');
                        setTimeout(() => {
                            window.location.href = '/rooms';
                        }, 3000);
                        return;
                    }
                    throw new Error(`Erreur ${response.status}`);
                }
                
                const roomData = await response.json();
                console.log('üìä Donn√©es room re√ßues:', roomData);
                
                if (roomData.success && roomData.room) {
                    // Chercher l'utilisateur actuel dans la room
                    const currentUser = findCurrentUser(roomData.room);
                    
                    if (currentUser) {
                        // Utilisateur trouv√© - mettre √† jour les donn√©es
                        userData.nickname = currentUser.nickname;
                        userData.role = currentUser.is_host ? 'host' : 'participant';
                        userData.user_id = currentUser.user_id;
                        
                        console.log('‚úÖ Utilisateur trouv√©:', {
                            nickname: userData.nickname,
                            role: userData.role,
                            id: userData.user_id
                        });
                        
                        updateUserDisplay();
                        
                        // Sauvegarder pour les prochaines visites
                        sessionStorage.setItem('userId', userData.user_id);
                        sessionStorage.setItem('userLang', userData.language);
                        
                    } else {
                        // Utilisateur pas dans la room - rediriger vers page de join
                        console.warn('‚ö†Ô∏è Utilisateur non trouv√© dans la room - redirection');
                        window.location.href = `/rooms?join=${userData.room_id}`;
                        return;
                    }
                } else {
                    throw new Error('Format de r√©ponse invalide');
                }
                
            } catch (error) {
                console.error('‚ùå Erreur lors de la r√©cup√©ration des donn√©es room:', error);
                
                // Si erreur API, proposer de rejoindre la room
                userData.nickname = 'Visiteur';
                userData.role = 'participant';
                updateUserDisplay();
                
                showUserNotification();
            }
        }
        
        function findCurrentUser(roomData) {
            // Strat√©gies pour trouver l'utilisateur actuel :
            
            // 1. Par userId exact (si on en a un)
            if (userData.user_id && userData.user_id !== 'demo') {
                const userByID = roomData.users?.find(user => user.user_id === userData.user_id);
                if (userByID) {
                    console.log('üë§ Utilisateur trouv√© par ID:', userByID);
                    return userByID;
                }
            }
            
            // 2. Si un seul utilisateur (l'h√¥te), c'est probablement lui
            if (roomData.users?.length === 1) {
                console.log('üëë Un seul utilisateur (h√¥te), s√©lection automatique');
                return roomData.users[0];
            }
            
            // 3. Demander √† l'utilisateur qui il est (si plusieurs)
            if (roomData.users?.length > 1) {
                console.log('üë• Plusieurs utilisateurs d√©tect√©s');
                // Pour l'instant, retourner null pour d√©clencher la redirection
                return null;
            }
            
            return null;
        }
        
        function handleUserNotInRoom(roomData) {
            // Afficher les infos de la room
            const roomName = roomData.room_name || 'Salle inconnue';
            const hostName = roomData.users?.find(u => u.is_host)?.nickname || 'H√¥te inconnu';
            
            // Proposer de rejoindre la room
            const joinDiv = document.createElement('div');
            joinDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                padding: 30px;
                border-radius: 15px;
                max-width: 400px;
                text-align: center;
                z-index: 1002;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            joinDiv.innerHTML = `
                <h3 style="margin-top: 0; color: #667eea;">üåç TradLive</h3>
                <p><strong>"${roomName}"</strong></p>
                <p>Cr√©√©e par <strong>${hostName}</strong></p>
                <p style="margin: 20px 0;">Voulez-vous rejoindre cette salle ?</p>
                <button onclick="joinThisRoom()" style="padding: 12px 24px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 5px; font-size: 16px;">
                    üë• Rejoindre la salle
                </button>
                <button onclick="goHome()" style="padding: 12px 24px; background: #666; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 5px; font-size: 16px;">
                    üè† Retour √† l'accueil
                </button>
            `;
            
            document.body.appendChild(joinDiv);
            
            // Ajouter les fonctions globales
            window.joinThisRoom = () => {
                window.location.href = `/rooms?join=${userData.room_id}`;
            };
            
            window.goHome = () => {
                window.location.href = '/rooms';
            };
        }
        
        async function initializeQRCode() {
            // Attendre que userData soit correctement initialis√©
            if (!userData || !userData.room_id) {
                console.warn('‚ö†Ô∏è userData pas encore initialis√© pour QR code');
                return;
            }
            
            // Seul l'h√¥te devrait avoir le QR code
            if (userData.role !== 'host') {
                console.log('üë§ Utilisateur participant - pas de QR code n√©cessaire');
                return;
            }
            
            // G√©n√©rer l'URL qui redirige directement vers la page de join
            const joinUrl = `${window.location.origin}/rooms?join=${userData.room_id}`;
            const qrUrl = `/qrcode?url=${encodeURIComponent(joinUrl)}`;
            qrImageEl.src = qrUrl;
            
            console.log('üì± QR Code g√©n√©r√© pour:', joinUrl);
        }
        
        async function initializeVoiceSystem() {
            voiceManager = new VoiceManager({
                roomId: userData.room_id,
                userId: userData.user_id,
                language: userData.language,
                isHost: true, // √Ä adapter selon votre logique
                onResult: handleVoiceResult,
                onError: handleVoiceError,
                onStatusChange: handleStatusChange
            });
            
            try {
                const method = await voiceManager.initialize();
                updateMethodDisplay(method);
                updateBrowserInfo();
                
                // Messages d'initialisation selon la m√©thode
                switch (method) {
                    case 'text':
                        showTextInput();
                        updateStatus('üí¨ Mode texte activ√©', 'info');
                        break;
                        
                    case 'azure':
                        micButton.disabled = false;
                        micButton.textContent = 'üé§ Parler (Azure)';
                        updateStatus('‚òÅÔ∏è Azure Speech pr√™t', 'connected');
                        break;
                        
                    case 'webspeech':
                        micButton.disabled = false;
                        micButton.textContent = 'üé§ Parler';
                        updateStatus('‚úÖ Web Speech pr√™t', 'connected');
                        break;
                        
                    default:
                        showTextInput();
                        updateStatus('üí¨ Mode texte par d√©faut', 'info');
                }
                
                // Afficher le bouton debug Azure si n√©cessaire
                const debugButton = document.getElementById('debug-azure-button');
                if (method === 'azure' || voiceManager.browserInfo.method === 'azure') {
                    debugButton.style.display = 'inline-block';
                }
                
            } catch (error) {
                console.error('Erreur init syst√®me vocal:', error);
                showTextInput();
                updateStatus('üí¨ Mode texte (erreur init)', 'error');
                showErrorNotification('Erreur d\'initialisation: ' + error.message);
            }
        }
        
        function updateMethodDisplay(method) {
            const methodNames = {
                'webspeech': 'Web Speech API',
                'azure': 'Azure Speech',
                'text': 'Mode Texte'
            };
            
            const methodClasses = {
                'webspeech': 'method-webspeech',
                'azure': 'method-azure',  
                'text': 'method-text'
            };
            
            voiceMethodEl.textContent = methodNames[method] || method;
            voiceMethodEl.className = `voice-method-indicator ${methodClasses[method] || ''}`;
        }
        
        function updateUserDisplay() {
            if (!userData.nickname || userData.nickname === 'Chargement...') {
                userNicknameEl.textContent = 'Chargement...';
                return;
            }
            
            const roleEmoji = userData.role === 'host' ? 'üëë' : 'üë§';
            const roleText = userData.role === 'host' ? 'H√¥te' : 'Participant';
            userNicknameEl.innerHTML = `${roleEmoji} ${userData.nickname} <span style="font-size: 11px; opacity: 0.7;">(${roleText})</span>`;
            
            // Afficher le QR code SEULEMENT pour l'h√¥te
            const qrImage = document.getElementById('qr-image');
            const qrCaption = document.getElementById('qr-caption');
            
            if (userData.role === 'host') {
                qrImage.style.display = 'block';
                qrCaption.style.display = 'block';
                // G√©n√©rer le QR code si pas encore fait
                if (!qrImage.src || qrImage.src === window.location.href) {
                    initializeQRCode();
                }
            } else {
                qrImage.style.display = 'none';
                qrCaption.style.display = 'none';
            }
        }
        
        function showUserNotification() {
            // Avertir que l'utilisateur devrait passer par le processus normal
            const notifDiv = document.createElement('div');
            notifDiv.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: rgba(255, 193, 7, 0.9);
                color: #333;
                padding: 15px 20px;
                border-radius: 10px;
                max-width: 300px;
                font-size: 14px;
                z-index: 1001;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            notifDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px;">‚ö†Ô∏è Acc√®s direct d√©tect√©</div>
                <div>Impossible de vous identifier. Rejoignez la salle via la page d'accueil pour utiliser toutes les fonctionnalit√©s.</div>
                <button onclick="window.location.href='/rooms'" style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üè† Aller √† l'accueil
                </button>
            `;
            
            document.body.appendChild(notifDiv);
            
            // Retirer apr√®s 15 secondes
            setTimeout(() => {
                if (notifDiv.parentNode) {
                    notifDiv.remove();
                }
            }, 15000);
        }
        
        function updateBrowserInfo() {
            const info = voiceManager.browserInfo;
            let infoText = `${info.name} - ${info.description}`;
            
            // Ajouter des avertissements sp√©cifiques
            if (info.limitation) {
                infoText += ` ‚ö†Ô∏è`;
                showBrowserLimitation(info.limitation);
            }
            
            browserInfoEl.textContent = infoText;
        }
        
        function showBrowserLimitation(limitation) {
            // Afficher une notification discr√®te sur les limitations
            const limitationDiv = document.createElement('div');
            limitationDiv.style.cssText = `
                background: rgba(255, 193, 7, 0.8);
                color: #333;
                padding: 10px;
                border-radius: 8px;
                margin: 10px 0;
                font-size: 14px;
                text-align: center;
            `;
            limitationDiv.textContent = `‚ÑπÔ∏è ${limitation}`;
            
            // L'ins√©rer temporairement
            const controls = document.getElementById('controls');
            controls.insertBefore(limitationDiv, controls.firstChild);
            
            // Retirer apr√®s 10 secondes
            setTimeout(() => {
                if (limitationDiv.parentNode) {
                    limitationDiv.remove();
                }
            }, 10000);
        }
        
        function updateUserDisplay() {
            userNicknameEl.textContent = userData.nickname;
        }
        
        function handleVoiceResult(result) {
            console.log('R√©sultat vocal:', result);
            
            // Afficher le texte original avec animation
            originalTextEl.classList.add('updating');
            originalTextEl.textContent = result.text;
            originalTextEl.classList.remove('empty-translation');
            
            setTimeout(() => {
                originalTextEl.classList.remove('updating');
            }, 300);
            
            // Afficher la confiance et le service
            if (result.confidence && result.confidence < 1) {
                confidenceDisplay.textContent = `Confiance: ${Math.round(result.confidence * 100)}% (${result.service})`;
                confidenceDisplay.style.display = 'block';
            } else {
                confidenceDisplay.style.display = 'none';
            }
            
            // Envoyer √† votre API de traduction
            sendForTranslation(result.text);
        }
        
        function handleVoiceError(error) {
            console.error('Erreur vocale:', error);
            showErrorNotification(error);
            
            // Auto-basculement vers mode texte apr√®s erreurs critiques
            if (error.includes('Microphone non autoris√©') || error.includes('Trop d\'erreurs')) {
                setTimeout(() => {
                    showTextInput();
                }, 2000);
            }
        }
        
        function handleStatusChange(status, message) {
            updateStatus(message, status);
            updateButtonState(status);
        }
        
        function updateStatus(message, className) {
            statusEl.textContent = message;
            statusEl.className = `status ${className}`;
        }
        
        function updateButtonState(status) {
            micButton.classList.remove('recording', 'processing');
            waveAnimation.classList.remove('active');
            
            switch (status) {
                case 'recording':
                    micButton.classList.add('recording');
                    micButton.textContent = 'üõë Arr√™ter';
                    waveAnimation.classList.add('active');
                    break;
                case 'processing':
                case 'uploading':
                    micButton.classList.add('processing');
                    micButton.textContent = '‚è≥ Traitement...';
                    micButton.disabled = true;
                    setTimeout(() => {
                        // Protection contre blocage infini
                        if (micButton.textContent === '‚è≥ Traitement...') {
                            micButton.textContent = 'üé§ Parler';
                            micButton.disabled = false;
                            micButton.classList.remove('processing');
                        }
                    }, 10000);
                    break;
                case 'success':
                case 'connected':
                case 'info':
                default:
                    micButton.textContent = 'üé§ Parler';
                    micButton.disabled = false;
                    break;
            }
        }
        
        function showErrorNotification(message) {
            errorMessage.textContent = message;
            errorNotification.classList.add('show');
            
            setTimeout(() => {
                errorNotification.classList.remove('show');
            }, 5000);
        }
        
        async function sendForTranslation(text) {
            // V√©rifier que l'utilisateur est identifi√©
            if (!userData.user_id || userData.user_id === 'demo' || userData.nickname === 'Chargement...') {
                updateStatus('‚ùå Utilisateur non identifi√©', 'error');
                showErrorNotification('Vous devez rejoindre la salle pour envoyer des messages');
                return;
            }
            
            try {
                updateStatus('üì§ Envoi de la traduction...', 'info');
                
                const response = await fetch(`/api/room/${userData.room_id}/translate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userData.user_id,
                        text: text,
                        source_language: userData.language
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        updateStatus('‚úÖ Message envoy√©', 'connected');
                    } else {
                        throw new Error(data.error);
                    }
                } else if (response.status === 403) {
                    // Utilisateur non autoris√© - recharger les donn√©es
                    updateStatus('üîÑ Rechargement des donn√©es...', 'info');
                    await loadRoomInfo();
                    throw new Error('Utilisateur non autoris√© - rechargement en cours');
                } else {
                    throw new Error('Erreur serveur de traduction');
                }
                
            } catch (error) {
                updateStatus('‚ùå Erreur de traduction', 'error');
                showErrorNotification('Erreur lors de l\'envoi: ' + error.message);
            }
        }
        
        // Event listeners
        micButton.addEventListener('click', function() {
            if (voiceManager.isListening) {
                voiceManager.stopListening();
            } else {
                voiceManager.startListening();
            }
        });
        
        textModeButton.addEventListener('click', showTextInput);
        
        function showTextInput() {
            textInputFallback.classList.add('show');
            document.getElementById('text-input').focus();
        }
        
        function hideTextInput() {
            textInputFallback.classList.remove('show');
        }
        
        function sendText() {
            const text = document.getElementById('text-input').value.trim();
            if (text) {
                handleVoiceResult({ text: text, confidence: 1, service: 'manual' });
                document.getElementById('text-input').value = '';
                hideTextInput();
            }
        }
        
        function tryVoiceAgain() {
            hideTextInput();
            // Reset compteur d'erreurs
            if (voiceManager) {
                voiceManager.errorCount = 0;
            }
            initializeVoiceSystem();
        }
        
        async function debugAzure() {
            // V√©rifier que l'utilisateur est identifi√©
            if (!userData.user_id || userData.user_id === 'demo' || userData.nickname === 'Chargement...') {
                showErrorNotification('Impossible de tester Azure - utilisateur non identifi√©');
                return;
            }
            
            updateStatus('üîß Test de configuration Azure...', 'info');
            
            try {
                console.log('üîß === DEBUG AZURE START ===');
                
                // 1. Tester la route de statut Azure
                console.log('üîß Test 1: V√©rification /api/speech-status');
                const statusResponse = await fetch('/api/speech-status');
                console.log('üîß Status response:', statusResponse.status, statusResponse.statusText);
                
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    console.log('üîß Status data:', statusData);
                    
                    if (!statusData.available) {
                        updateStatus('‚ùå Azure non configur√© sur le serveur', 'error');
                        showErrorNotification('Azure Speech Service non configur√©. V√©rifiez les variables AZURE_SPEECH_KEY et AZURE_SPEECH_REGION sur Render.');
                        return;
                    }
                } else {
                    updateStatus('‚ùå Route Azure inaccessible', 'error');
                    showErrorNotification('Route /api/speech-status introuvable. V√©rifiez le d√©ploiement backend.');
                    return;
                }
                
                // 2. Tester l'enregistrement audio
                console.log('üîß Test 2: V√©rification MediaRecorder');
                if (!('MediaRecorder' in window)) {
                    updateStatus('‚ùå MediaRecorder non support√©', 'error');
                    showErrorNotification('Votre navigateur ne supporte pas MediaRecorder. Utilisez Chrome, Firefox ou Edge.');
                    return;
                }
                
                // 3. Tester l'acc√®s microphone
                console.log('üîß Test 3: Test acc√®s microphone');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('üîß Microphone OK');
                    stream.getTracks().forEach(track => track.stop());
                } catch (micError) {
                    updateStatus('‚ùå Microphone inaccessible', 'error');
                    showErrorNotification('Acc√®s microphone refus√©. Autorisez le microphone dans votre navigateur.');
                    console.error('üîß Erreur microphone:', micError);
                    return;
                }
                
                // 4. Test Azure avec audio factice
                console.log('üîß Test 4: Test Azure avec donn√©es factices');
                const fakeBlob = new Blob(['fake audio data for testing'], { type: 'audio/wav' });
                const formData = new FormData();
                formData.append('audio', fakeBlob, 'test.wav');
                formData.append('language', userData.language);
                formData.append('room_id', userData.room_id);
                formData.append('user_id', userData.user_id);
                
                const testResponse = await fetch('/api/transcribe-audio', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('üîß Test Azure response:', testResponse.status, testResponse.statusText);
                
                if (testResponse.ok) {
                    const testData = await testResponse.json();
                    console.log('üîß Test Azure data:', testData);
                    updateStatus('‚úÖ Configuration Azure OK', 'connected');
                    showErrorNotification('Azure fonctionne ! Le probl√®me pourrait venir du format audio r√©el.');
                } else {
                    const errorText = await testResponse.text();
                    console.error('üîß Erreur test Azure:', errorText);
                    updateStatus('‚ùå Azure √©choue', 'error');
                    showErrorNotification('Azure retourne erreur 500. V√©rifiez les logs Render et la configuration Azure.');
                }
                
                console.log('üîß === DEBUG AZURE END ===');
                
            } catch (error) {
                console.error('üîß Erreur debug Azure:', error);
                updateStatus('‚ùå Erreur debug Azure', 'error');
                showErrorNotification('Erreur pendant le debug: ' + error.message);
            }
        }
        
        async function debugAzure() {
            updateStatus('üîß Test de configuration Azure...', 'info');
            
            try {
                console.log('üîß === DEBUG AZURE START ===');
                
                // 1. Tester la route de statut Azure
                console.log('üîß Test 1: V√©rification /api/speech-status');
                const statusResponse = await fetch('/api/speech-status');
                console.log('üîß Status response:', statusResponse.status, statusResponse.statusText);
                
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    console.log('üîß Status data:', statusData);
                    
                    if (!statusData.available) {
                        updateStatus('‚ùå Azure non configur√© sur le serveur', 'error');
                        showErrorNotification('Azure Speech Service non configur√©. V√©rifiez les variables AZURE_SPEECH_KEY et AZURE_SPEECH_REGION sur Render.');
                        return;
                    }
                } else {
                    updateStatus('‚ùå Route Azure inaccessible', 'error');
                    showErrorNotification('Route /api/speech-status introuvable. V√©rifiez le d√©ploiement backend.');
                    return;
                }
                
                // 2. Tester l'enregistrement audio
                console.log('üîß Test 2: V√©rification MediaRecorder');
                if (!('MediaRecorder' in window)) {
                    updateStatus('‚ùå MediaRecorder non support√©', 'error');
                    showErrorNotification('Votre navigateur ne supporte pas MediaRecorder. Utilisez Chrome, Firefox ou Edge.');
                    return;
                }
                
                // 3. Tester l'acc√®s microphone
                console.log('üîß Test 3: Test acc√®s microphone');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('üîß Microphone OK');
                    stream.getTracks().forEach(track => track.stop());
                } catch (micError) {
                    updateStatus('‚ùå Microphone inaccessible', 'error');
                    showErrorNotification('Acc√®s microphone refus√©. Autorisez le microphone dans votre navigateur.');
                    console.error('üîß Erreur microphone:', micError);
                    return;
                }
                
                // 4. Test Azure avec audio factice
                console.log('üîß Test 4: Test Azure avec donn√©es factices');
                const fakeBlob = new Blob(['fake audio data'], { type: 'audio/wav' });
                const formData = new FormData();
                formData.append('audio', fakeBlob, 'test.wav');
                formData.append('language', 'fr');
                formData.append('room_id', userData.room_id);
                formData.append('user_id', userData.user_id);
                
                const testResponse = await fetch('/api/transcribe-audio', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('üîß Test Azure response:', testResponse.status, testResponse.statusText);
                
                if (testResponse.ok) {
                    const testData = await testResponse.json();
                    console.log('üîß Test Azure data:', testData);
                    updateStatus('‚úÖ Configuration Azure OK', 'connected');
                    showErrorNotification('Azure fonctionne ! Le probl√®me vient peut-√™tre du format audio.');
                } else {
                    const errorText = await testResponse.text();
                    console.error('üîß Erreur test Azure:', errorText);
                    updateStatus('‚ùå Azure √©choue', 'error');
                    showErrorNotification('Azure retourne erreur 500. V√©rifiez les logs Render et la configuration Azure.');
                }
                
                console.log('üîß === DEBUG AZURE END ===');
                
            } catch (error) {
                console.error('üîß Erreur debug Azure:', error);
                updateStatus('‚ùå Erreur debug Azure', 'error');
                showErrorNotification('Erreur pendant le debug: ' + error.message);
            }
        }
        
        function leaveRoom() {
            if (confirm('Quitter la salle ?')) {
                if (voiceManager) voiceManager.cleanup();
                if (updateInterval) clearInterval(updateInterval);
                window.location.href = '/rooms';
            }
        }
        
        function startRealTimeUpdates() {
            updateInterval = setInterval(async () => {
                // V√©rifier que l'utilisateur est bien identifi√©
                if (!userData.user_id || userData.user_id === 'demo' || userData.nickname === 'Chargement...') {
                    console.log('‚ö†Ô∏è Utilisateur non identifi√©, pas de mise √† jour');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/room/${userData.room_id}/updates?user_id=${userData.user_id}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.translated) {
                            // Afficher la nouvelle traduction
                            translatedTextEl.classList.add('updating');
                            translatedTextEl.textContent = data.translated;
                            translatedTextEl.classList.remove('empty-translation');
                            
                            setTimeout(() => {
                                translatedTextEl.classList.remove('updating');
                            }, 300);
                            
                            // Synth√®se vocale si activ√©e
                            if (data.enable_speech && data.translated) {
                                speakText(data.translated);
                            }
                        }
                        updateErrorCount = 0; // Reset apr√®s succ√®s
                    } else if (response.status === 403) {
                        // Utilisateur non autoris√© - recharger les donn√©es
                        console.log('üîÑ Utilisateur non autoris√© - rechargement des donn√©es...');
                        await loadRoomInfo();
                    }
                } catch (error) {
                    updateErrorCount++;
                    console.log('Erreur mise √† jour:', error);
                    
                    // Arr√™ter apr√®s trop d'erreurs pour √©viter les boucles
                    if (updateErrorCount >= maxUpdateErrors) {
                        console.log('Trop d\'erreurs de mise √† jour - arr√™t');
                        clearInterval(updateInterval);
                    }
                }
            }, 3000);
        }
        
        function speakText(text) {
            try {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = userData.language === 'fr' ? 'fr-FR' : `${userData.language}-${userData.language.toUpperCase()}`;
                    utterance.rate = 0.9;
                    utterance.pitch = 1;
                    speechSynthesis.speak(utterance);
                }
            } catch (error) {
                console.log('Erreur synth√®se vocale:', error);
            }
        }
        
        // Gestion Entr√©e pour envoyer
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                if (document.getElementById('text-input') === document.activeElement) {
                    e.preventDefault();
                    sendText();
                }
            }
        });
        
        // Nettoyage √† la fermeture
        window.addEventListener('beforeunload', function() {
            if (voiceManager) voiceManager.cleanup();
            if (updateInterval) clearInterval(updateInterval);
        });
        
        // Heartbeat pour maintenir la session
        setInterval(() => {
            // Seulement si l'utilisateur est identifi√©
            if (userData && userData.user_id && userData.user_id !== 'demo' && userData.nickname !== 'Chargement...') {
                fetch(`/api/room/${userData.room_id}/heartbeat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: userData.user_id })
                }).catch(err => console.log('Heartbeat error:', err));
            }
        }, 15000);
    </script>
</body>
</html>
