<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradLive - Salle {{ room_id }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .room-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .voice-method-indicator {
            background: rgba(33, 150, 243, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin: 10px 0;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .method-whisper { background: rgba(76, 175, 80, 0.9); }
        .method-speech { background: rgba(255, 193, 7, 0.9); color: #333; }
        .method-text { background: rgba(244, 67, 54, 0.9); }
        
        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .status.connected { background: rgba(76, 175, 80, 0.8); }
        .status.error { background: rgba(244, 67, 54, 0.8); }
        .status.info { background: rgba(33, 150, 243, 0.8); }
        .status.recording { background: rgba(255, 193, 7, 0.8); color: #333; }
        .status.processing { background: rgba(156, 39, 176, 0.8); }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .mic-button {
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 50px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            min-width: 250px;
            position: relative;
            overflow: hidden;
        }
        
        .mic-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .mic-button.recording {
            background: linear-gradient(45deg, #f44336, #da190b);
            animation: pulse 2s infinite;
        }
        
        .mic-button.processing {
            background: linear-gradient(45deg, #9c27b0, #7b1fa2);
            animation: processing 1.5s infinite;
        }
        
        .mic-button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }
        
        @keyframes processing {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .recording-timer {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            display: none;
        }
        
        .mic-button.recording .recording-timer {
            display: block;
        }
        
        .text-mode-button {
            padding: 10px 20px;
            background: rgba(33, 150, 243, 0.8);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        
        .translation-area {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            min-height: 200px;
        }
        
        .translation-section {
            margin-bottom: 20px;
        }
        
        .translation-label {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }
        
        .translation-text {
            font-size: 18px;
            line-height: 1.5;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            min-height: 60px;
            word-wrap: break-word;
            transition: all 0.3s ease;
        }
        
        .translation-text.updating {
            background: rgba(255, 193, 7, 0.3);
            transform: scale(1.02);
        }
        
        .empty-translation {
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        
        .wave-animation {
            display: none;
            justify-content: center;
            align-items: center;
            height: 40px;
            margin: 10px 0;
        }
        
        .wave-animation.active {
            display: flex;
        }
        
        .wave-bar {
            display: inline-block;
            width: 5px;
            background-color: #FFD700;
            margin: 0 3px;
            border-radius: 2px;
            animation: waveAnimation 0.5s infinite alternate;
        }
        
        @keyframes waveAnimation {
            0% { height: 10px; }
            100% { height: 30px; }
        }
        
        .wave-bar:nth-child(1) { animation-delay: 0.1s; }
        .wave-bar:nth-child(2) { animation-delay: 0.2s; }
        .wave-bar:nth-child(3) { animation-delay: 0.3s; }
        .wave-bar:nth-child(4) { animation-delay: 0.4s; }
        .wave-bar:nth-child(5) { animation-delay: 0.3s; }
        
        .text-input-fallback {
            display: none;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 2px solid rgba(33, 150, 243, 0.5);
        }
        
        .text-input-fallback.show {
            display: block;
        }
        
        .text-input-fallback textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: none;
            min-height: 80px;
            margin-bottom: 10px;
            box-sizing: border-box;
            font-size: 16px;
            resize: vertical;
        }
        
        .text-input-fallback button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        
        .confidence-indicator {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .error-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 4px solid #f44336;
            max-width: 300px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .error-notification.show {
            transform: translateX(0);
        }
        
        @media (max-width: 600px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .room-info {
                flex-direction: column;
                text-align: center;
            }
            
            .mic-button {
                width: 100%;
                margin: 5px 0;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç TradLive</h1>
            <div class="room-info">
                <div class="room-code">Salle : <span id="room-id">{{ room_id }}</span></div>
                <div class="user-info">
                    <span id="user-nickname">Chargement...</span>
                    <div id="voice-method" class="voice-method-indicator">D√©tection en cours...</div>
                </div>
                <button class="leave-button" onclick="leaveRoom()">üö™ Quitter</button>
            </div>
        </div>
        
        <div id="status" class="status info">Initialisation du syst√®me vocal...</div>
        
        <div id="controls" class="controls">
            <button id="mic-button" class="mic-button" disabled>
                üé§ Initialisation...
                <div class="recording-timer" id="recording-timer">0s</div>
            </button>
            <button id="text-mode-button" class="text-mode-button">üí¨ Mode Texte</button>
            
            <div class="wave-animation" id="wave-animation">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>
            
            <div id="text-input-fallback" class="text-input-fallback">
                <h4 id="text-input-title">‚úçÔ∏è Saisie de texte</h4>
                <textarea id="text-input" placeholder="√âcrivez votre message ici..."></textarea>
                <button onclick="sendText()">üì§ Envoyer</button>
                <button onclick="hideTextInput()">‚ùå Fermer</button>
                <button onclick="tryVoiceAgain()">üé§ R√©essayer le micro</button>
            </div>
        </div>
        
        <div class="translation-area">
            <div class="translation-section">
                <div class="translation-label">üìù Message original</div>
                <div id="original-text" class="translation-text empty-translation">
                    En attente de votre message...
                </div>
                <div id="confidence-display" class="confidence-indicator" style="display: none;"></div>
            </div>
            
            <div class="translation-section">
                <div class="translation-label">üåç Traduction</div>
                <div id="translated-text" class="translation-text empty-translation">
                    En attente d'une traduction...
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification d'erreur -->
    <div id="error-notification" class="error-notification">
        <div id="error-message"></div>
    </div>
    
    <script>
        // üéµ CLASSES COMPL√àTES POUR WHISPER ET FALLBACK
        class WhisperAudioRecorder {
            constructor(options = {}) {
                this.isRecording = false;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.stream = null;
                this.recordingTimeout = null;
                this.recordingStartTime = null;
                this.maxRecordingTime = options.maxRecordingTime || 30000;
                this.minRecordingTime = options.minRecordingTime || 1000;
                this.apiEndpoint = options.apiEndpoint || '/api/transcribe-audio';
                this.language = options.language || 'fr';
                this.roomId = options.roomId || null;
                this.userId = options.userId || null;
                
                this.onResult = options.onResult || (() => {});
                this.onError = options.onError || (() => {});
                this.onStatusChange = options.onStatusChange || (() => {});
            }
            
            static isSupported() {
                return 'MediaRecorder' in window && 'mediaDevices' in navigator;
            }
            
            async initialize() {
                if (!WhisperAudioRecorder.isSupported()) {
                    throw new Error('MediaRecorder non support√©');
                }
                
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    const options = {
                        mimeType: this.getSupportedMimeType(),
                        audioBitsPerSecond: 128000
                    };
                    
                    this.mediaRecorder = new MediaRecorder(this.stream, options);
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        this.processRecording();
                    };
                    
                    this.mediaRecorder.onerror = (event) => {
                        this.onError('Erreur MediaRecorder: ' + event.error);
                    };
                    
                    console.log('‚úÖ Whisper MediaRecorder initialis√©');
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Erreur init Whisper:', error);
                    throw error;
                }
            }
            
            getSupportedMimeType() {
                const types = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/mp4',
                    'audio/wav'
                ];
                
                for (const type of types) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        return type;
                    }
                }
                return '';
            }
            
            async startRecording() {
                if (this.isRecording) return;
                
                try {
                    if (!this.mediaRecorder) {
                        await this.initialize();
                    }
                    
                    this.audioChunks = [];
                    this.recordingStartTime = Date.now();
                    
                    this.mediaRecorder.start(1000);
                    this.isRecording = true;
                    
                    this.recordingTimeout = setTimeout(() => {
                        if (this.isRecording) {
                            this.stopRecording();
                        }
                    }, this.maxRecordingTime);
                    
                    this.onStatusChange('recording', 'Enregistrement en cours...');
                    
                } catch (error) {
                    this.onError('Impossible de d√©marrer l\'enregistrement: ' + error.message);
                    this.isRecording = false;
                }
            }
            
            stopRecording() {
                if (!this.isRecording) return;
                
                if (this.recordingTimeout) {
                    clearTimeout(this.recordingTimeout);
                    this.recordingTimeout = null;
                }
                
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                }
                
                this.isRecording = false;
                this.onStatusChange('processing', 'Traitement en cours...');
            }
            
            async processRecording() {
                if (this.audioChunks.length === 0) {
                    this.onError('Aucune donn√©e audio enregistr√©e');
                    return;
                }
                
                try {
                    const audioBlob = new Blob(this.audioChunks, { 
                        type: this.getSupportedMimeType() || 'audio/wav' 
                    });
                    
                    if (audioBlob.size < 1000) {
                        this.onError('Enregistrement trop court');
                        return;
                    }
                    
                    await this.sendToServer(audioBlob);
                    
                } catch (error) {
                    this.onError('Erreur de traitement: ' + error.message);
                }
            }
            
            async sendToServer(audioBlob) {
                try {
                    this.onStatusChange('uploading', 'Envoi au serveur...');
                    
                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'recording.wav');
                    formData.append('language', this.language);
                    
                    if (this.roomId) formData.append('room_id', this.roomId);
                    if (this.userId) formData.append('user_id', this.userId);
                    
                    const response = await fetch(this.apiEndpoint, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Erreur serveur: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.onResult({
                            text: data.text,
                            detected_language: data.detected_language,
                            confidence: data.confidence || 1
                        });
                        this.onStatusChange('success', 'Transcription r√©ussie');
                    } else {
                        throw new Error(data.error || 'Erreur de transcription');
                    }
                    
                } catch (error) {
                    this.onError('Erreur de communication: ' + error.message);
                    this.onStatusChange('error', 'Erreur de communication');
                }
            }
            
            cleanup() {
                if (this.recordingTimeout) {
                    clearTimeout(this.recordingTimeout);
                }
                
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                this.isRecording = false;
                this.audioChunks = [];
            }
            
            getRecordingDuration() {
                if (!this.recordingStartTime) return 0;
                return Math.floor((Date.now() - this.recordingStartTime) / 1000);
            }
        }
        
        // üß† GESTIONNAIRE INTELLIGENT PRINCIPAL
        class IntelligentVoiceManager {
            constructor(options = {}) {
                this.roomId = options.roomId;
                this.userId = options.userId;
                this.language = options.language || 'fr';
                this.isHost = options.isHost || false;
                
                this.onResult = options.onResult || (() => {});
                this.onError = options.onError || (() => {});
                this.onStatusChange = options.onStatusChange || (() => {});
                
                this.speechRecognition = null;
                this.whisperRecorder = null;
                this.currentMethod = null;
                this.isListening = false;
                this.recordingTimer = null;
                
                this.browserInfo = this.detectBrowser();
            }
            
            detectBrowser() {
                const ua = navigator.userAgent;
                let browser = { name: 'unknown', compatibility: 'unknown', recommendation: '' };
                
                if (ua.includes('Chrome') && !ua.includes('Edge') && !ua.includes('Brave')) {
                    browser = { name: 'Chrome', compatibility: 'excellent', recommendation: 'Parfait !' };
                } else if (ua.includes('Brave')) {
                    browser = { name: 'Brave', compatibility: 'problematic', recommendation: 'Whisper recommand√©' };
                } else if (ua.includes('Edge')) {
                    browser = { name: 'Edge', compatibility: 'good', recommendation: 'Tr√®s compatible' };
                } else if (ua.includes('Firefox')) {
                    browser = { name: 'Firefox', compatibility: 'limited', recommendation: 'Whisper recommand√©' };
                } else if (ua.includes('Safari')) {
                    browser = { name: 'Safari', compatibility: 'poor', recommendation: 'Mode texte recommand√©' };
                }
                
                return browser;
            }
            
            async detectBestMethod() {
                const capabilities = {
                    speechRecognition: 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window,
                    mediaRecorder: WhisperAudioRecorder.isSupported(),
                    browser: this.browserInfo
                };
                
                // Priorit√© √† Whisper pour Brave et navigateurs probl√©matiques
                if (capabilities.mediaRecorder && (this.browserInfo.compatibility === 'problematic' || this.browserInfo.compatibility === 'limited')) {
                    return 'whisper';
                }
                
                // V√©rifier si Whisper est disponible c√¥t√© serveur
                try {
                    const response = await fetch('/api/whisper-status');
                    if (response.ok) {
                        const data = await response.json();
                        if (data.available && capabilities.mediaRecorder) {
                            return 'whisper';
                        }
                    }
                } catch (error) {
                    console.log('Whisper non disponible c√¥t√© serveur');
                }
                
                // Fallback sur Speech Recognition si disponible
                if (capabilities.speechRecognition && this.browserInfo.compatibility !== 'poor') {
                    return 'speech';
                }
                
                return 'text';
            }
            
            async initialize() {
                const method = await this.detectBestMethod();
                this.currentMethod = method;
                
                try {
                    switch (method) {
                        case 'whisper':
                            await this.initializeWhisper();
                            break;
                        case 'speech':
                            await this.initializeSpeechRecognition();
                            break;
                        default:
                            this.onStatusChange('text', 'Mode texte activ√©');
                            break;
                    }
                    return method;
                } catch (error) {
                    console.error('Erreur initialisation:', error);
                    this.currentMethod = 'text';
                    this.onStatusChange('text', 'Mode texte activ√© (erreur init)');
                    return 'text';
                }
            }
            
            async initializeWhisper() {
                this.whisperRecorder = new WhisperAudioRecorder({
                    apiEndpoint: '/api/transcribe-audio',
                    language: this.language,
                    roomId: this.roomId,
                    userId: this.userId,
                    onResult: this.onResult,
                    onError: this.onError,
                    onStatusChange: this.onStatusChange
                });
                
                await this.whisperRecorder.initialize();
            }
            
            async initializeSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                this.speechRecognition = new SpeechRecognition();
                this.speechRecognition.lang = this.language === 'fr' ? 'fr-FR' : `${this.language}-${this.language.toUpperCase()}`;
                this.speechRecognition.continuous = false;
                this.speechRecognition.interimResults = true;
                
                this.speechRecognition.onresult = (event) => {
                    const lastResult = event.results[event.results.length - 1];
                    const transcript = lastResult[0].transcript;
                    
                    if (lastResult.isFinal) {
                        this.onResult({ 
                            text: transcript, 
                            confidence: lastResult[0].confidence || 0.9 
                        });
                    }
                };
                
                this.speechRecognition.onerror = (event) => {
                    if (event.error === 'network') {
                        this.onError('Erreur r√©seau Speech Recognition - basculement vers Whisper recommand√©');
                    } else {
                        this.onError('Speech Recognition: ' + event.error);
                    }
                };
            }
            
            async startListening() {
                if (this.isListening) return;
                
                this.isListening = true;
                
                switch (this.currentMethod) {
                    case 'whisper':
                        if (this.whisperRecorder) {
                            await this.whisperRecorder.startRecording();
                            this.startRecordingTimer();
                        }
                        break;
                    case 'speech':
                        if (this.speechRecognition) {
                            try {
                                this.speechRecognition.start();
                            } catch (error) {
                                this.onError('Erreur Speech Recognition: ' + error.message);
                                this.isListening = false;
                            }
                        }
                        break;
                    default:
                        this.onStatusChange('text', 'Utilisez le mode texte');
                        this.isListening = false;
                        break;
                }
            }
            
            stopListening() {
                if (!this.isListening) return;
                
                this.isListening = false;
                this.stopRecordingTimer();
                
                switch (this.currentMethod) {
                    case 'whisper':
                        if (this.whisperRecorder) {
                            this.whisperRecorder.stopRecording();
                        }
                        break;
                    case 'speech':
                        if (this.speechRecognition) {
                            this.speechRecognition.stop();
                        }
                        break;
                }
            }
            
            startRecordingTimer() {
                const timerEl = document.getElementById('recording-timer');
                let seconds = 0;
                
                this.recordingTimer = setInterval(() => {
                    seconds++;
                    if (timerEl) {
                        timerEl.textContent = `${seconds}s`;
                    }
                }, 1000);
            }
            
            stopRecordingTimer() {
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                    this.recordingTimer = null;
                }
                
                const timerEl = document.getElementById('recording-timer');
                if (timerEl) {
                    timerEl.textContent = '0s';
                }
            }
            
            cleanup() {
                this.stopRecordingTimer();
                
                if (this.whisperRecorder) {
                    this.whisperRecorder.cleanup();
                }
                if (this.speechRecognition) {
                    this.speechRecognition = null;
                }
            }
            
            getStatus() {
                return {
                    method: this.currentMethod,
                    isListening: this.isListening,
                    browser: this.browserInfo
                };
            }
        }
        
        // üöÄ INT√âGRATION DANS L'INTERFACE
        let voiceManager;
        let userData = { room_id: '{{ room_id }}', user_id: 'demo', language: 'fr' };
        let updateInterval;
        
        // √âl√©ments DOM
        const statusEl = document.getElementById('status');
        const micButton = document.getElementById('mic-button');
        const textModeButton = document.getElementById('text-mode-button');
        const waveAnimation = document.getElementById('wave-animation');
        const textInputFallback = document.getElementById('text-input-fallback');
        const originalTextEl = document.getElementById('original-text');
        const translatedTextEl = document.getElementById('translated-text');
        const confidenceDisplay = document.getElementById('confidence-display');
        const voiceMethodEl = document.getElementById('voice-method');
        const errorNotification = document.getElementById('error-notification');
        const errorMessage = document.getElementById('error-message');
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeVoiceSystem();
            startRealTimeUpdates();
        });
        
        async function initializeVoiceSystem() {
            voiceManager = new IntelligentVoiceManager({
                roomId: userData.room_id,
                userId: userData.user_id,
                language: userData.language,
                isHost: true, // Simul√©
                onResult: handleVoiceResult,
                onError: handleVoiceError,
                onStatusChange: handleStatusChange
            });
            
            try {
                const method = await voiceManager.initialize();
                updateMethodDisplay(method);
                
                if (method === 'text') {
                    showTextInput();
                } else {
                    micButton.disabled = false;
                    micButton.textContent = 'üé§ Parler';
                }
                
            } catch (error) {
                console.error('Erreur init syst√®me vocal:', error);
                showTextInput();
            }
        }
        
        function updateMethodDisplay(method) {
            const methodNames = {
                'whisper': 'Whisper (Serveur)',
                'speech': 'Speech Recognition',
                'text': 'Mode Texte'
            };
            
            const methodClasses = {
                'whisper': 'method-whisper',
                'speech': 'method-speech',  
                'text': 'method-text'
            };
            
            voiceMethodEl.textContent = methodNames[method] || method;
            voiceMethodEl.className = `voice-method-indicator ${methodClasses[method] || ''}`;
        }
        
        function handleVoiceResult(result) {
            console.log('R√©sultat vocal:', result);
            
            // Afficher le texte original avec animation
            originalTextEl.classList.add('updating');
            originalTextEl.textContent = result.text;
            originalTextEl.classList.remove('empty-translation');
            
            setTimeout(() => {
                originalTextEl.classList.remove('updating');
            }, 300);
            
            // Afficher la confiance si disponible
            if (result.confidence && result.confidence < 1) {
                confidenceDisplay.textContent = `Confiance: ${Math.round(result.confidence * 100)}%`;
                confidenceDisplay.style.display = 'block';
            } else {
                confidenceDisplay.style.display = 'none';
            }
            
            // Simuler traduction (remplace par ton API de traduction)
            simulateTranslation(result.text);
        }
        
        function handleVoiceError(error) {
            console.error('Erreur vocale:', error);
            showErrorNotification(error);
            
            // Auto-basculement vers mode texte apr√®s 3 erreurs
            if (error.includes('network') || error.includes('communication')) {
                setTimeout(() => {
                    showTextInput();
                }, 2000);
            }
        }
        
        function handleStatusChange(status, message) {
            updateStatus(message, status);
            updateButtonState(status);
        }
        
        function updateStatus(message, className) {
            statusEl.textContent = message;
            statusEl.className = `status ${className}`;
        }
        
        function updateButtonState(status) {
            micButton.classList.remove('recording', 'processing');
            waveAnimation.classList.remove('active');
            
            switch (status) {
                case 'recording':
                    micButton.classList.add('recording');
                    micButton.textContent = 'üé§ Arr√™ter';
                    waveAnimation.classList.add('active');
                    break;
                case 'processing':
                case 'uploading':
                    micButton.classList.add('processing');
                    micButton.textContent = '‚è≥ Traitement...';
                    micButton.disabled = true;
                    break;
                case 'success':
                case 'connected':
                case 'info':
                default:
                    micButton.textContent = 'üé§ Parler';
                    micButton.disabled = false;
                    break;
            }
        }
        
        function showErrorNotification(message) {
            errorMessage.textContent = message;
            errorNotification.classList.add('show');
            
            setTimeout(() => {
                errorNotification.classList.remove('show');
            }, 5000);
        }
        
        function simulateTranslation(text) {
            updateStatus('üì§ Traduction en cours...', 'info');
            
            // Simuler d√©lai API
            setTimeout(() => {
                translatedTextEl.classList.add('updating');
                translatedTextEl.textContent = `[EN] ${text}`;
                translatedTextEl.classList.remove('empty-translation');
                
                setTimeout(() => {
                    translatedTextEl.classList.remove('updating');
                }, 300);
                
                updateStatus('‚úÖ Traduction termin√©e', 'connected');
            }, 1000);
        }
        
        // Event listeners
        micButton.addEventListener('click', function() {
            if (voiceManager.isListening) {
                voiceManager.stopListening();
            } else {
                voiceManager.startListening();
            }
        });
        
        textModeButton.addEventListener('click', showTextInput);
        
        function showTextInput() {
            textInputFallback.classList.add('show');
            document.getElementById('text-input').focus();
        }
        
        function hideTextInput() {
            textInputFallback.classList.remove('show');
        }
        
        function sendText() {
            const text = document.getElementById('text-input').value.trim();
            if (text) {
                handleVoiceResult({ text: text, confidence: 1 });
                document.getElementById('text-input').value = '';
                hideTextInput();
            }
        }
        
        function tryVoiceAgain() {
            hideTextInput();
            initializeVoiceSystem();
        }
        
        function leaveRoom() {
            if (confirm('Quitter la salle ?')) {
                if (voiceManager) voiceManager.cleanup();
                if (updateInterval) clearInterval(updateInterval);
                window.location.href = '/rooms';
            }
        }
        
        function startRealTimeUpdates() {
            // Simuler des mises √† jour en temps r√©el
            updateInterval = setInterval(() => {
                // Ici tu peux appeler ton API pour r√©cup√©rer les nouvelles traductions
                console.log('V√©rification des mises √† jour...');
            }, 3000);
        }
        
        // Gestion Entr√©e pour envoyer
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                if (document.getElementById('text-input') === document.activeElement) {
                    e.preventDefault();
                    sendText();
                }
            }
        });
        
        // Nettoyage √† la fermeture
        window.addEventListener('beforeunload', function() {
            if (voiceManager) voiceManager.cleanup();
            if (updateInterval) clearInterval(updateInterval);
        });
    </script>
</body>
</html>
